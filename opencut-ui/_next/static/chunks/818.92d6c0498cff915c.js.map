{"version":3,"file":"static/chunks/818.92d6c0498cff915c.js","mappings":"uBAAA,cAGA,mCACA,yCAEA,OADA,0BACA,CACA,CAAE,CACF,CACA,cACA,YACA,WACA,cCXA,KAGA,cAEA,WACA,cACA,iBAGA,YAGA,UACA,EAGA,KACA,IACA,oBACA,IACA,EAAG,OACH,eAIA,iBC3BA,4ECIO,MECP,EFFO,oCAAmD,aAAa,kBAEvE,YACA,cACA,cACA,oBACA,0BACA,wBACA,4BACA,kBACA,0BACA,sBACA,0BACA,gBACA,sBACA,sBACA,YACA,gBACA,mBACA,CAAC,UAAsC,ECtBhC,oCACA,kEACA,mCACA,+CCGP,SAAsB,gCAA8D,IACpF,SACA,IACA,GACA,GAAuB,EAAQ,CAE/B,gBACA,CACA,MAMA,GALA,OAAsC,GACtC,GAAuB,EAAQ,0BAE/B,6BAAuC,SACZ,EAAQ,CAAC,SACpC,uBACA,MAAkB,CAElB,CACA,QACA,UAJsC,IAItC,kBACA,KAEA,gCAWA,MAVA,gCAGA,uBAAgC,EAAQ,GAAG,6BAAsB,cAAoB,GAAG,GACnF,EACL,+BAAkD,KAAM,EAAa,cACrE,mCACA,KAAc,EAAa,SAC3B,EAD2B,GAC3B,CACA,CAAK,GACL,CACA,CA6DA,uBAA0B,SAAQ,gBAAuB,CAAG,IAC5D,IACA,EADA,KAEA,IACA,OAAqB,EAAa,SAClC,EADkC,IAChB,EAClB,UACA,IAFkC,CAEjB,CAFmB,CAEN,KAC9B,MAD8B,EAC9B,KACA,KACA,MAAiB,EAAa,KAC9B,EAvEA,IAsE8B,IAtEd,eAAoB,IACpC,gBACA,aACA,YAEA,OADA,UACA,EACA,EAiEA,GACA,KACA,MAAiB,EAAa,QAC9B,EAnEA,QAAmB,eAAoB,IACvC,gBACA,gBACA,YAEA,OADA,UACA,EACA,EA6DA,GACA,KACA,MAAiB,EAAa,aAC9B,CA/DA,OAAqB,SAAY,IACjC,oBACA,GACA,EA4DA,GACA,KACA,MAAiB,EAAa,UAC9B,CAD8B,CA7D9B,QAAoB,aAAgB,6BAAgC,GAAU,EA8D9E,GACA,KACA,MAAiB,EAAa,YAC9B,EA/DA,QAAsB,EAAM,IAC5B,eACA,GACA,EA4DA,GACA,KACA,MAAiB,EAAa,OAC9B,EA9DA,WAAkB,YAAkB,IACpC,iBACA,GACA,EA2DA,GACA,KACA,MAAiB,EAAa,WAC9B,GA5DA,OAAqB,EAAM,IAC3B,cACA,GACA,EAyDA,GACA,KACA,MAAiB,EAAa,SAC9B,GA3DA,OAAmB,EAAM,IACzB,sBACA,KACA,gBACA,mBAAuC,EAAK,GAAG,EAAK,GACpD,qBACA,aAAqB,UAAa,CAClC,CACA,SACA,EAkDA,GACA,KACA,MAAiB,EAAa,aAlD9B,QAAqB,EAAM,IAC3B,cACA,GACA,EAgDA,GACA,KACA,MAAiB,EAAa,MAC9B,EAlDA,GAiD8B,OAjDb,yBAA6B,IAE9C,uBADA,EACA,OACA,MAEA,kBACA,IACA,EA2CA,GACA,KACA,MAAiB,EAAa,QAC9B,EA7CA,CA4C8B,CA5C9B,YAAmB,EAAY,IAC/B,gBACA,GACA,EA0CA,GACA,KACA,SACA,MAAsB,CACtB,CACA,CACA,SACA,cAJgD,EAIhD,EACA,KACA,KAAkB,EAAa,MAC/B,KAD+B,EAC/B,UACA,CAAS,EACT,MACA,CACA,yBACA,iBAEA,qBAAuB,gBAAgB,GACvC","sources":["webpack://_N_E/../../node_modules/.bun/@ffmpeg+ffmpeg@0.12.15/node_modules/@ffmpeg/ffmpeg/dist/esm/ lazy namespace object","webpack://_N_E/webpack/bootstrap","webpack://_N_E/webpack/runtime/hasOwnProperty shorthand","webpack://_N_E/../../node_modules/.bun/@ffmpeg+ffmpeg@0.12.15/node_modules/@ffmpeg/ffmpeg/dist/esm/const.js","webpack://_N_E/../../node_modules/.bun/@ffmpeg+ffmpeg@0.12.15/node_modules/@ffmpeg/ffmpeg/dist/esm/errors.js","webpack://_N_E/../../node_modules/.bun/@ffmpeg+ffmpeg@0.12.15/node_modules/@ffmpeg/ffmpeg/dist/esm/worker.js"],"sourcesContent":["function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(() => {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = () => ([]);\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = 92031;\nmodule.exports = webpackEmptyAsyncContext;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export const MIME_TYPE_JAVASCRIPT = \"text/javascript\";\nexport const MIME_TYPE_WASM = \"application/wasm\";\nexport const CORE_VERSION = \"0.12.9\";\nexport const CORE_URL = `https://unpkg.com/@ffmpeg/core@${CORE_VERSION}/dist/umd/ffmpeg-core.js`;\nexport var FFMessageType;\n(function (FFMessageType) {\n    FFMessageType[\"LOAD\"] = \"LOAD\";\n    FFMessageType[\"EXEC\"] = \"EXEC\";\n    FFMessageType[\"FFPROBE\"] = \"FFPROBE\";\n    FFMessageType[\"WRITE_FILE\"] = \"WRITE_FILE\";\n    FFMessageType[\"READ_FILE\"] = \"READ_FILE\";\n    FFMessageType[\"DELETE_FILE\"] = \"DELETE_FILE\";\n    FFMessageType[\"RENAME\"] = \"RENAME\";\n    FFMessageType[\"CREATE_DIR\"] = \"CREATE_DIR\";\n    FFMessageType[\"LIST_DIR\"] = \"LIST_DIR\";\n    FFMessageType[\"DELETE_DIR\"] = \"DELETE_DIR\";\n    FFMessageType[\"ERROR\"] = \"ERROR\";\n    FFMessageType[\"DOWNLOAD\"] = \"DOWNLOAD\";\n    FFMessageType[\"PROGRESS\"] = \"PROGRESS\";\n    FFMessageType[\"LOG\"] = \"LOG\";\n    FFMessageType[\"MOUNT\"] = \"MOUNT\";\n    FFMessageType[\"UNMOUNT\"] = \"UNMOUNT\";\n})(FFMessageType || (FFMessageType = {}));\n","export const ERROR_UNKNOWN_MESSAGE_TYPE = new Error(\"unknown message type\");\nexport const ERROR_NOT_LOADED = new Error(\"ffmpeg is not loaded, call `await ffmpeg.load()` first\");\nexport const ERROR_TERMINATED = new Error(\"called FFmpeg.terminate()\");\nexport const ERROR_IMPORT_FAILURE = new Error(\"failed to import ffmpeg-core.js\");\n","/// <reference no-default-lib=\"true\" />\n/// <reference lib=\"esnext\" />\n/// <reference lib=\"webworker\" />\nimport { CORE_URL, FFMessageType } from \"./const.js\";\nimport { ERROR_UNKNOWN_MESSAGE_TYPE, ERROR_NOT_LOADED, ERROR_IMPORT_FAILURE, } from \"./errors.js\";\nlet ffmpeg;\nconst load = async ({ coreURL: _coreURL, wasmURL: _wasmURL, workerURL: _workerURL, }) => {\n    const first = !ffmpeg;\n    try {\n        if (!_coreURL)\n            _coreURL = CORE_URL;\n        // when web worker type is `classic`.\n        importScripts(_coreURL);\n    }\n    catch {\n        if (!_coreURL || _coreURL === CORE_URL)\n            _coreURL = CORE_URL.replace('/umd/', '/esm/');\n        // when web worker type is `module`.\n        self.createFFmpegCore = (await import(\n        /* @vite-ignore */ _coreURL)).default;\n        if (!self.createFFmpegCore) {\n            throw ERROR_IMPORT_FAILURE;\n        }\n    }\n    const coreURL = _coreURL;\n    const wasmURL = _wasmURL ? _wasmURL : _coreURL.replace(/.js$/g, \".wasm\");\n    const workerURL = _workerURL\n        ? _workerURL\n        : _coreURL.replace(/.js$/g, \".worker.js\");\n    ffmpeg = await self.createFFmpegCore({\n        // Fix `Overload resolution failed.` when using multi-threaded ffmpeg-core.\n        // Encoded wasmURL and workerURL in the URL as a hack to fix locateFile issue.\n        mainScriptUrlOrBlob: `${coreURL}#${btoa(JSON.stringify({ wasmURL, workerURL }))}`,\n    });\n    ffmpeg.setLogger((data) => self.postMessage({ type: FFMessageType.LOG, data }));\n    ffmpeg.setProgress((data) => self.postMessage({\n        type: FFMessageType.PROGRESS,\n        data,\n    }));\n    return first;\n};\nconst exec = ({ args, timeout = -1 }) => {\n    ffmpeg.setTimeout(timeout);\n    ffmpeg.exec(...args);\n    const ret = ffmpeg.ret;\n    ffmpeg.reset();\n    return ret;\n};\nconst ffprobe = ({ args, timeout = -1 }) => {\n    ffmpeg.setTimeout(timeout);\n    ffmpeg.ffprobe(...args);\n    const ret = ffmpeg.ret;\n    ffmpeg.reset();\n    return ret;\n};\nconst writeFile = ({ path, data }) => {\n    ffmpeg.FS.writeFile(path, data);\n    return true;\n};\nconst readFile = ({ path, encoding }) => ffmpeg.FS.readFile(path, { encoding });\n// TODO: check if deletion works.\nconst deleteFile = ({ path }) => {\n    ffmpeg.FS.unlink(path);\n    return true;\n};\nconst rename = ({ oldPath, newPath }) => {\n    ffmpeg.FS.rename(oldPath, newPath);\n    return true;\n};\n// TODO: check if creation works.\nconst createDir = ({ path }) => {\n    ffmpeg.FS.mkdir(path);\n    return true;\n};\nconst listDir = ({ path }) => {\n    const names = ffmpeg.FS.readdir(path);\n    const nodes = [];\n    for (const name of names) {\n        const stat = ffmpeg.FS.stat(`${path}/${name}`);\n        const isDir = ffmpeg.FS.isDir(stat.mode);\n        nodes.push({ name, isDir });\n    }\n    return nodes;\n};\n// TODO: check if deletion works.\nconst deleteDir = ({ path }) => {\n    ffmpeg.FS.rmdir(path);\n    return true;\n};\nconst mount = ({ fsType, options, mountPoint }) => {\n    const str = fsType;\n    const fs = ffmpeg.FS.filesystems[str];\n    if (!fs)\n        return false;\n    ffmpeg.FS.mount(fs, options, mountPoint);\n    return true;\n};\nconst unmount = ({ mountPoint }) => {\n    ffmpeg.FS.unmount(mountPoint);\n    return true;\n};\nself.onmessage = async ({ data: { id, type, data: _data }, }) => {\n    const trans = [];\n    let data;\n    try {\n        if (type !== FFMessageType.LOAD && !ffmpeg)\n            throw ERROR_NOT_LOADED; // eslint-disable-line\n        switch (type) {\n            case FFMessageType.LOAD:\n                data = await load(_data);\n                break;\n            case FFMessageType.EXEC:\n                data = exec(_data);\n                break;\n            case FFMessageType.FFPROBE:\n                data = ffprobe(_data);\n                break;\n            case FFMessageType.WRITE_FILE:\n                data = writeFile(_data);\n                break;\n            case FFMessageType.READ_FILE:\n                data = readFile(_data);\n                break;\n            case FFMessageType.DELETE_FILE:\n                data = deleteFile(_data);\n                break;\n            case FFMessageType.RENAME:\n                data = rename(_data);\n                break;\n            case FFMessageType.CREATE_DIR:\n                data = createDir(_data);\n                break;\n            case FFMessageType.LIST_DIR:\n                data = listDir(_data);\n                break;\n            case FFMessageType.DELETE_DIR:\n                data = deleteDir(_data);\n                break;\n            case FFMessageType.MOUNT:\n                data = mount(_data);\n                break;\n            case FFMessageType.UNMOUNT:\n                data = unmount(_data);\n                break;\n            default:\n                throw ERROR_UNKNOWN_MESSAGE_TYPE;\n        }\n    }\n    catch (e) {\n        self.postMessage({\n            id,\n            type: FFMessageType.ERROR,\n            data: e.toString(),\n        });\n        return;\n    }\n    if (data instanceof Uint8Array) {\n        trans.push(data.buffer);\n    }\n    self.postMessage({ id, type, data }, trans);\n};\n"],"names":[],"sourceRoot":"","ignoreList":[0,1,2,3,4,5]}