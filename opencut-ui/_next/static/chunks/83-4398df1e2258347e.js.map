{"version":3,"file":"static/chunks/83-4398df1e2258347e.js","mappings":"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","sources":["webpack://_N_E/./src/lib/timeline.ts","webpack://_N_E/./src/stores/timeline-store.ts","webpack://_N_E/./src/types/timeline.ts","webpack://_N_E/./src/lib/storage/indexeddb-adapter.ts","webpack://_N_E/./src/lib/storage/opfs-adapter.ts","webpack://_N_E/./src/lib/storage/storage-service.ts","webpack://_N_E/./src/stores/editor-store.ts","webpack://_N_E/./src/stores/media-store.ts","webpack://_N_E/./src/stores/project-store.ts","webpack://_N_E/./src/constants/timeline-constants.ts","webpack://_N_E/./src/lib/utils.ts"],"sourcesContent":["import { TimelineElement } from \"@/types/timeline\";\r\n\r\n// Helper function to check for element overlaps and prevent invalid timeline states\r\nexport const checkElementOverlaps = (elements: TimelineElement[]): boolean => {\r\n  // Sort elements by start time\r\n  const sortedElements = [...elements].sort(\r\n    (a, b) => a.startTime - b.startTime\r\n  );\r\n\r\n  for (let i = 0; i < sortedElements.length - 1; i++) {\r\n    const current = sortedElements[i];\r\n    const next = sortedElements[i + 1];\r\n\r\n    const currentEnd =\r\n      current.startTime +\r\n      (current.duration - current.trimStart - current.trimEnd);\r\n\r\n    // Check if current element overlaps with next element\r\n    if (currentEnd > next.startTime) return true; // Overlap detected\r\n  }\r\n\r\n  return false; // No overlaps\r\n};\r\n\r\n// Helper function to resolve overlaps by adjusting element positions\r\nexport const resolveElementOverlaps = (\r\n  elements: TimelineElement[]\r\n): TimelineElement[] => {\r\n  // Sort elements by start time\r\n  const sortedElements = [...elements].sort(\r\n    (a, b) => a.startTime - b.startTime\r\n  );\r\n  const resolvedElements: TimelineElement[] = [];\r\n\r\n  for (let i = 0; i < sortedElements.length; i++) {\r\n    const current = { ...sortedElements[i] };\r\n\r\n    if (resolvedElements.length > 0) {\r\n      const previous = resolvedElements[resolvedElements.length - 1];\r\n      const previousEnd =\r\n        previous.startTime +\r\n        (previous.duration - previous.trimStart - previous.trimEnd);\r\n\r\n      // If current element would overlap with previous, push it after previous ends\r\n      if (current.startTime < previousEnd) {\r\n        current.startTime = previousEnd;\r\n      }\r\n    }\r\n\r\n    resolvedElements.push(current);\r\n  }\r\n\r\n  return resolvedElements;\r\n};\r\n","import { create } from \"zustand\";\r\nimport {\r\n  TrackType,\r\n  TimelineElement,\r\n  CreateTimelineElement,\r\n  TimelineTrack,\r\n  TextElement,\r\n  DragData,\r\n  sortTracksByOrder,\r\n  ensureMainTrack,\r\n  validateElementTrackCompatibility,\r\n} from \"@/types/timeline\";\r\nimport { useEditorStore } from \"./editor-store\";\r\nimport {\r\n  useMediaStore,\r\n  getMediaAspectRatio,\r\n  type MediaItem,\r\n} from \"./media-store\";\r\nimport { storageService } from \"@/lib/storage/storage-service\";\r\nimport { useProjectStore } from \"./project-store\";\r\nimport { generateUUID } from \"@/lib/utils\";\r\nimport { TIMELINE_CONSTANTS } from \"@/constants/timeline-constants\";\r\nimport { toast } from \"sonner\";\r\nimport { checkElementOverlaps, resolveElementOverlaps } from \"@/lib/timeline\";\r\n\r\n// Helper function to manage element naming with suffixes\r\nconst getElementNameWithSuffix = (\r\n  originalName: string,\r\n  suffix: string\r\n): string => {\r\n  // Remove existing suffixes to prevent accumulation\r\n  const baseName = originalName\r\n    .replace(/ \\(left\\)$/, \"\")\r\n    .replace(/ \\(right\\)$/, \"\")\r\n    .replace(/ \\(audio\\)$/, \"\")\r\n    .replace(/ \\(split \\d+\\)$/, \"\");\r\n\r\n  return `${baseName} (${suffix})`;\r\n};\r\n\r\ninterface TimelineStore {\r\n  // Private track storage\r\n  _tracks: TimelineTrack[];\r\n  history: TimelineTrack[][];\r\n  redoStack: TimelineTrack[][];\r\n\r\n  // Always returns properly ordered tracks with main track ensured\r\n  tracks: TimelineTrack[];\r\n\r\n  // Manual method if you need to force recomputation\r\n  getSortedTracks: () => TimelineTrack[];\r\n\r\n  // Snapping settings\r\n  snappingEnabled: boolean;\r\n\r\n  // Snapping actions\r\n  toggleSnapping: () => void;\r\n\r\n  // Ripple editing mode\r\n  rippleEditingEnabled: boolean;\r\n  toggleRippleEditing: () => void;\r\n\r\n  // Multi-selection\r\n  selectedElements: { trackId: string; elementId: string }[];\r\n  selectElement: (trackId: string, elementId: string, multi?: boolean) => void;\r\n  deselectElement: (trackId: string, elementId: string) => void;\r\n  clearSelectedElements: () => void;\r\n  setSelectedElements: (\r\n    elements: { trackId: string; elementId: string }[]\r\n  ) => void;\r\n\r\n  // Drag state\r\n  dragState: {\r\n    isDragging: boolean;\r\n    elementId: string | null;\r\n    trackId: string | null;\r\n    startMouseX: number;\r\n    startElementTime: number;\r\n    clickOffsetTime: number;\r\n    currentTime: number;\r\n  };\r\n  setDragState: (dragState: Partial<TimelineStore[\"dragState\"]>) => void;\r\n  startDrag: (\r\n    elementId: string,\r\n    trackId: string,\r\n    startMouseX: number,\r\n    startElementTime: number,\r\n    clickOffsetTime: number\r\n  ) => void;\r\n  updateDragTime: (currentTime: number) => void;\r\n  endDrag: () => void;\r\n\r\n  // Actions\r\n  addTrack: (type: TrackType) => string;\r\n  insertTrackAt: (type: TrackType, index: number) => string;\r\n  removeTrack: (trackId: string) => void;\r\n  removeTrackWithRipple: (trackId: string) => void;\r\n  addElementToTrack: (trackId: string, element: CreateTimelineElement) => void;\r\n  removeElementFromTrack: (\r\n    trackId: string,\r\n    elementId: string,\r\n    pushHistory?: boolean\r\n  ) => void;\r\n  moveElementToTrack: (\r\n    fromTrackId: string,\r\n    toTrackId: string,\r\n    elementId: string\r\n  ) => void;\r\n  updateElementTrim: (\r\n    trackId: string,\r\n    elementId: string,\r\n    trimStart: number,\r\n    trimEnd: number,\r\n    pushHistory?: boolean\r\n  ) => void;\r\n  updateElementDuration: (\r\n    trackId: string,\r\n    elementId: string,\r\n    duration: number,\r\n    pushHistory?: boolean\r\n  ) => void;\r\n  updateElementStartTime: (\r\n    trackId: string,\r\n    elementId: string,\r\n    startTime: number,\r\n    pushHistory?: boolean\r\n  ) => void;\r\n  toggleTrackMute: (trackId: string) => void;\r\n  toggleElementHidden: (trackId: string, elementId: string) => void;\r\n\r\n  // Split operations for elements\r\n  splitElement: (\r\n    trackId: string,\r\n    elementId: string,\r\n    splitTime: number\r\n  ) => string | null;\r\n  splitAndKeepLeft: (\r\n    trackId: string,\r\n    elementId: string,\r\n    splitTime: number\r\n  ) => void;\r\n  splitAndKeepRight: (\r\n    trackId: string,\r\n    elementId: string,\r\n    splitTime: number\r\n  ) => void;\r\n  separateAudio: (trackId: string, elementId: string) => string | null;\r\n\r\n  // Replace media for an element\r\n  replaceElementMedia: (\r\n    trackId: string,\r\n    elementId: string,\r\n    newFile: File\r\n  ) => Promise<{ success: boolean; error?: string }>;\r\n\r\n  // Ripple editing functions\r\n  updateElementStartTimeWithRipple: (\r\n    trackId: string,\r\n    elementId: string,\r\n    newStartTime: number\r\n  ) => void;\r\n  removeElementFromTrackWithRipple: (\r\n    trackId: string,\r\n    elementId: string,\r\n    pushHistory?: boolean\r\n  ) => void;\r\n\r\n  // Computed values\r\n  getTotalDuration: () => number;\r\n  getProjectThumbnail: (projectId: string) => Promise<string | null>;\r\n\r\n  // History actions\r\n  undo: () => void;\r\n  redo: () => void;\r\n  pushHistory: () => void;\r\n\r\n  // Persistence actions\r\n  loadProjectTimeline: (projectId: string) => Promise<void>;\r\n  saveProjectTimeline: (projectId: string) => Promise<void>;\r\n  clearTimeline: () => void;\r\n  updateTextElement: (\r\n    trackId: string,\r\n    elementId: string,\r\n    updates: Partial<\r\n      Pick<\r\n        TextElement,\r\n        | \"content\"\r\n        | \"fontSize\"\r\n        | \"fontFamily\"\r\n        | \"color\"\r\n        | \"backgroundColor\"\r\n        | \"textAlign\"\r\n        | \"fontWeight\"\r\n        | \"fontStyle\"\r\n        | \"textDecoration\"\r\n        | \"x\"\r\n        | \"y\"\r\n        | \"rotation\"\r\n        | \"opacity\"\r\n      >\r\n    >\r\n  ) => void;\r\n  checkElementOverlap: (\r\n    trackId: string,\r\n    startTime: number,\r\n    duration: number,\r\n    excludeElementId?: string\r\n  ) => boolean;\r\n  findOrCreateTrack: (trackType: TrackType) => string;\r\n  addMediaAtTime: (item: MediaItem, currentTime?: number) => boolean;\r\n  addTextAtTime: (item: TextElement, currentTime?: number) => boolean;\r\n  addMediaToNewTrack: (item: MediaItem) => boolean;\r\n  addTextToNewTrack: (item: TextElement | DragData) => boolean;\r\n}\r\n\r\nexport const useTimelineStore = create<TimelineStore>((set, get) => {\r\n  // Helper to update tracks and maintain ordering\r\n  const updateTracks = (newTracks: TimelineTrack[]) => {\r\n    const tracksWithMain = ensureMainTrack(newTracks);\r\n    const sortedTracks = sortTracksByOrder(tracksWithMain);\r\n    set({\r\n      _tracks: tracksWithMain,\r\n      tracks: sortedTracks,\r\n    });\r\n  };\r\n\r\n  // Helper to auto-save timeline changes\r\n  const autoSaveTimeline = async () => {\r\n    const activeProject = useProjectStore.getState().activeProject;\r\n    if (activeProject) {\r\n      try {\r\n        await storageService.saveTimeline(activeProject.id, get()._tracks);\r\n      } catch (error) {\r\n        console.error(\"Failed to auto-save timeline:\", error);\r\n      }\r\n    }\r\n  };\r\n\r\n  // Helper to update tracks and auto-save\r\n  const updateTracksAndSave = (newTracks: TimelineTrack[]) => {\r\n    updateTracks(newTracks);\r\n    // Auto-save in background\r\n    setTimeout(autoSaveTimeline, 100);\r\n  };\r\n\r\n  // Initialize with proper track ordering\r\n  const initialTracks = ensureMainTrack([]);\r\n  const sortedInitialTracks = sortTracksByOrder(initialTracks);\r\n\r\n  return {\r\n    _tracks: initialTracks,\r\n    tracks: sortedInitialTracks,\r\n    history: [],\r\n    redoStack: [],\r\n    selectedElements: [],\r\n    rippleEditingEnabled: false,\r\n\r\n    // Snapping settings defaults\r\n    snappingEnabled: true,\r\n\r\n    getSortedTracks: () => {\r\n      const { _tracks } = get();\r\n      const tracksWithMain = ensureMainTrack(_tracks);\r\n      return sortTracksByOrder(tracksWithMain);\r\n    },\r\n\r\n    pushHistory: () => {\r\n      const { _tracks, history } = get();\r\n      set({\r\n        history: [...history, JSON.parse(JSON.stringify(_tracks))],\r\n        redoStack: [],\r\n      });\r\n    },\r\n\r\n    undo: () => {\r\n      const { history, redoStack, _tracks } = get();\r\n      if (history.length === 0) return;\r\n      const prev = history[history.length - 1];\r\n      updateTracksAndSave(prev);\r\n      set({\r\n        history: history.slice(0, -1),\r\n        redoStack: [...redoStack, JSON.parse(JSON.stringify(_tracks))],\r\n      });\r\n    },\r\n\r\n    selectElement: (trackId, elementId, multi = false) => {\r\n      set((state) => {\r\n        const exists = state.selectedElements.some(\r\n          (c) => c.trackId === trackId && c.elementId === elementId\r\n        );\r\n        if (multi) {\r\n          return exists\r\n            ? {\r\n                selectedElements: state.selectedElements.filter(\r\n                  (c) => !(c.trackId === trackId && c.elementId === elementId)\r\n                ),\r\n              }\r\n            : {\r\n                selectedElements: [\r\n                  ...state.selectedElements,\r\n                  { trackId, elementId },\r\n                ],\r\n              };\r\n        }\r\n        return { selectedElements: [{ trackId, elementId }] };\r\n      });\r\n    },\r\n\r\n    deselectElement: (trackId, elementId) => {\r\n      set((state) => ({\r\n        selectedElements: state.selectedElements.filter(\r\n          (c) => !(c.trackId === trackId && c.elementId === elementId)\r\n        ),\r\n      }));\r\n    },\r\n\r\n    clearSelectedElements: () => {\r\n      set({ selectedElements: [] });\r\n    },\r\n\r\n    setSelectedElements: (elements) => set({ selectedElements: elements }),\r\n\r\n    addTrack: (type) => {\r\n      get().pushHistory();\r\n\r\n      // Generate proper track name based on type\r\n      const trackName =\r\n        type === \"media\"\r\n          ? \"Media Track\"\r\n          : type === \"text\"\r\n            ? \"Text Track\"\r\n            : type === \"audio\"\r\n              ? \"Audio Track\"\r\n              : \"Track\";\r\n\r\n      const newTrack: TimelineTrack = {\r\n        id: generateUUID(),\r\n        name: trackName,\r\n        type,\r\n        elements: [],\r\n        muted: false,\r\n      };\r\n\r\n      updateTracksAndSave([...get()._tracks, newTrack]);\r\n      return newTrack.id;\r\n    },\r\n\r\n    insertTrackAt: (type, index) => {\r\n      get().pushHistory();\r\n\r\n      // Generate proper track name based on type\r\n      const trackName =\r\n        type === \"media\"\r\n          ? \"Media Track\"\r\n          : type === \"text\"\r\n            ? \"Text Track\"\r\n            : type === \"audio\"\r\n              ? \"Audio Track\"\r\n              : \"Track\";\r\n\r\n      const newTrack: TimelineTrack = {\r\n        id: generateUUID(),\r\n        name: trackName,\r\n        type,\r\n        elements: [],\r\n        muted: false,\r\n      };\r\n\r\n      const newTracks = [...get()._tracks];\r\n      newTracks.splice(index, 0, newTrack);\r\n      updateTracksAndSave(newTracks);\r\n      return newTrack.id;\r\n    },\r\n\r\n    removeTrack: (trackId) => {\r\n      const { rippleEditingEnabled } = get();\r\n\r\n      if (rippleEditingEnabled) {\r\n        get().removeTrackWithRipple(trackId);\r\n      } else {\r\n        get().pushHistory();\r\n        updateTracksAndSave(\r\n          get()._tracks.filter((track) => track.id !== trackId)\r\n        );\r\n      }\r\n    },\r\n\r\n    removeTrackWithRipple: (trackId) => {\r\n      const { _tracks } = get();\r\n      const trackToRemove = _tracks.find((t) => t.id === trackId);\r\n\r\n      if (!trackToRemove) return;\r\n\r\n      get().pushHistory();\r\n\r\n      // If track has no elements, just remove it normally\r\n      if (trackToRemove.elements.length === 0) {\r\n        updateTracksAndSave(_tracks.filter((track) => track.id !== trackId));\r\n        return;\r\n      }\r\n\r\n      // Find all the time ranges occupied by elements in the track being removed\r\n      const occupiedRanges = trackToRemove.elements.map((element) => ({\r\n        startTime: element.startTime,\r\n        endTime:\r\n          element.startTime +\r\n          (element.duration - element.trimStart - element.trimEnd),\r\n      }));\r\n\r\n      // Sort ranges by start time\r\n      occupiedRanges.sort((a, b) => a.startTime - b.startTime);\r\n\r\n      // Merge overlapping ranges to get consolidated gaps\r\n      const mergedRanges: Array<{\r\n        startTime: number;\r\n        endTime: number;\r\n        duration: number;\r\n      }> = [];\r\n\r\n      for (const range of occupiedRanges) {\r\n        if (mergedRanges.length === 0) {\r\n          mergedRanges.push({\r\n            startTime: range.startTime,\r\n            endTime: range.endTime,\r\n            duration: range.endTime - range.startTime,\r\n          });\r\n        } else {\r\n          const lastRange = mergedRanges[mergedRanges.length - 1];\r\n          if (range.startTime <= lastRange.endTime) {\r\n            // Overlapping or adjacent ranges, merge them\r\n            lastRange.endTime = Math.max(lastRange.endTime, range.endTime);\r\n            lastRange.duration = lastRange.endTime - lastRange.startTime;\r\n          } else {\r\n            // Non-overlapping range, add as new\r\n            mergedRanges.push({\r\n              startTime: range.startTime,\r\n              endTime: range.endTime,\r\n              duration: range.endTime - range.startTime,\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove the track and apply ripple effects to remaining tracks\r\n      const updatedTracks = _tracks\r\n        .filter((track) => track.id !== trackId)\r\n        .map((track) => {\r\n          const updatedElements = track.elements.map((element) => {\r\n            let newStartTime = element.startTime;\r\n\r\n            // Process gaps from right to left (latest to earliest) to avoid cumulative shifts\r\n            for (let i = mergedRanges.length - 1; i >= 0; i--) {\r\n              const gap = mergedRanges[i];\r\n              // If this element starts after the gap, shift it left by the gap duration\r\n              if (newStartTime >= gap.endTime) {\r\n                newStartTime -= gap.duration;\r\n              }\r\n            }\r\n\r\n            return {\r\n              ...element,\r\n              startTime: Math.max(0, newStartTime),\r\n            };\r\n          });\r\n\r\n          // Check for overlaps and resolve them if necessary\r\n          const hasOverlaps = checkElementOverlaps(updatedElements);\r\n          if (hasOverlaps) {\r\n            const resolvedElements = resolveElementOverlaps(updatedElements);\r\n            return { ...track, elements: resolvedElements };\r\n          }\r\n\r\n          return { ...track, elements: updatedElements };\r\n        });\r\n\r\n      updateTracksAndSave(updatedTracks);\r\n    },\r\n\r\n    addElementToTrack: (trackId, elementData) => {\r\n      get().pushHistory();\r\n\r\n      // Validate element type matches track type\r\n      const track = get()._tracks.find((t) => t.id === trackId);\r\n      if (!track) {\r\n        console.error(\"Track not found:\", trackId);\r\n        return;\r\n      }\r\n\r\n      // Use utility function for validation\r\n      const validation = validateElementTrackCompatibility(elementData, track);\r\n      if (!validation.isValid) {\r\n        console.error(validation.errorMessage);\r\n        return;\r\n      }\r\n\r\n      // For media elements, validate mediaId exists\r\n      if (elementData.type === \"media\" && !elementData.mediaId) {\r\n        console.error(\"Media element must have mediaId\");\r\n        return;\r\n      }\r\n\r\n      // For text elements, validate required text properties\r\n      if (elementData.type === \"text\" && !elementData.content) {\r\n        console.error(\"Text element must have content\");\r\n        return;\r\n      }\r\n\r\n      // Check if this is the first element being added to the timeline\r\n      const currentState = get();\r\n      const totalElementsInTimeline = currentState._tracks.reduce(\r\n        (total, track) => total + track.elements.length,\r\n        0\r\n      );\r\n      const isFirstElement = totalElementsInTimeline === 0;\r\n\r\n      const newElement: TimelineElement = {\r\n        ...elementData,\r\n        id: generateUUID(),\r\n        startTime: elementData.startTime || 0,\r\n        trimStart: 0,\r\n        trimEnd: 0,\r\n      } as TimelineElement; // Type assertion since we trust the caller passes valid data\r\n\r\n      // If this is the first element and it's a media element, automatically set the project canvas size\r\n      // to match the media's aspect ratio and FPS (for videos)\r\n      if (isFirstElement && newElement.type === \"media\") {\r\n        const mediaStore = useMediaStore.getState();\r\n        const mediaItem = mediaStore.mediaItems.find(\r\n          (item) => item.id === newElement.mediaId\r\n        );\r\n\r\n        if (\r\n          mediaItem &&\r\n          (mediaItem.type === \"image\" || mediaItem.type === \"video\")\r\n        ) {\r\n          const editorStore = useEditorStore.getState();\r\n          editorStore.setCanvasSizeFromAspectRatio(\r\n            getMediaAspectRatio(mediaItem)\r\n          );\r\n        }\r\n\r\n        // Set project FPS from the first video element\r\n        if (mediaItem && mediaItem.type === \"video\" && mediaItem.fps) {\r\n          const projectStore = useProjectStore.getState();\r\n          if (projectStore.activeProject) {\r\n            projectStore.updateProjectFps(mediaItem.fps);\r\n          }\r\n        }\r\n      }\r\n\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? { ...track, elements: [...track.elements, newElement] }\r\n            : track\r\n        )\r\n      );\r\n\r\n      get().selectElement(trackId, newElement.id);\r\n    },\r\n\r\n    removeElementFromTrack: (trackId, elementId, pushHistory = true) => {\r\n      const { rippleEditingEnabled } = get();\r\n\r\n      if (rippleEditingEnabled) {\r\n        get().removeElementFromTrackWithRipple(trackId, elementId, pushHistory);\r\n      } else {\r\n        if (pushHistory) get().pushHistory();\r\n        updateTracksAndSave(\r\n          get()\r\n            ._tracks.map((track) =>\r\n              track.id === trackId\r\n                ? {\r\n                    ...track,\r\n                    elements: track.elements.filter(\r\n                      (element) => element.id !== elementId\r\n                    ),\r\n                  }\r\n                : track\r\n            )\r\n            .filter((track) => track.elements.length > 0)\r\n        );\r\n      }\r\n    },\r\n\r\n    removeElementFromTrackWithRipple: (\r\n      trackId,\r\n      elementId,\r\n      pushHistory = true\r\n    ) => {\r\n      const { _tracks, rippleEditingEnabled } = get();\r\n\r\n      if (!rippleEditingEnabled) {\r\n        // If ripple editing is disabled, use regular removal\r\n        get().removeElementFromTrack(trackId, elementId, pushHistory);\r\n        return;\r\n      }\r\n\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((e) => e.id === elementId);\r\n\r\n      if (!element || !track) return;\r\n\r\n      if (pushHistory) get().pushHistory();\r\n\r\n      const elementStartTime = element.startTime;\r\n      const elementDuration =\r\n        element.duration - element.trimStart - element.trimEnd;\r\n      const elementEndTime = elementStartTime + elementDuration;\r\n\r\n      // Remove the element and shift all elements that come after it\r\n      const updatedTracks = _tracks\r\n        .map((currentTrack) => {\r\n          // Only apply ripple effects to the same track unless multi-track ripple is enabled\r\n          const shouldApplyRipple = currentTrack.id === trackId;\r\n\r\n          const updatedElements = currentTrack.elements\r\n            .filter((currentElement) => {\r\n              // Remove the target element\r\n              if (\r\n                currentElement.id === elementId &&\r\n                currentTrack.id === trackId\r\n              ) {\r\n                return false;\r\n              }\r\n              return true;\r\n            })\r\n            .map((currentElement) => {\r\n              // Only apply ripple effects if we should process this track\r\n              if (!shouldApplyRipple) {\r\n                return currentElement;\r\n              }\r\n\r\n              // Shift elements that start after the removed element\r\n              if (currentElement.startTime >= elementEndTime) {\r\n                return {\r\n                  ...currentElement,\r\n                  startTime: Math.max(\r\n                    0,\r\n                    currentElement.startTime - elementDuration\r\n                  ),\r\n                };\r\n              }\r\n              return currentElement;\r\n            });\r\n\r\n          // Check for overlaps and resolve them if necessary\r\n          const hasOverlaps = checkElementOverlaps(updatedElements);\r\n          if (hasOverlaps) {\r\n            // Resolve overlaps by adjusting element positions\r\n            const resolvedElements = resolveElementOverlaps(updatedElements);\r\n            return { ...currentTrack, elements: resolvedElements };\r\n          }\r\n\r\n          return { ...currentTrack, elements: updatedElements };\r\n        })\r\n        .filter((track) => track.elements.length > 0 || track.isMain);\r\n\r\n      updateTracksAndSave(updatedTracks);\r\n    },\r\n\r\n    moveElementToTrack: (fromTrackId, toTrackId, elementId) => {\r\n      get().pushHistory();\r\n\r\n      const fromTrack = get()._tracks.find((track) => track.id === fromTrackId);\r\n      const toTrack = get()._tracks.find((track) => track.id === toTrackId);\r\n      const elementToMove = fromTrack?.elements.find(\r\n        (element) => element.id === elementId\r\n      );\r\n\r\n      if (!elementToMove || !toTrack) return;\r\n\r\n      // Validate element type compatibility with target track\r\n      const validation = validateElementTrackCompatibility(\r\n        elementToMove,\r\n        toTrack\r\n      );\r\n      if (!validation.isValid) {\r\n        console.error(validation.errorMessage);\r\n        return;\r\n      }\r\n\r\n      const newTracks = get()\r\n        ._tracks.map((track) => {\r\n          if (track.id === fromTrackId) {\r\n            return {\r\n              ...track,\r\n              elements: track.elements.filter(\r\n                (element) => element.id !== elementId\r\n              ),\r\n            };\r\n          }\r\n          if (track.id === toTrackId) {\r\n            return {\r\n              ...track,\r\n              elements: [...track.elements, elementToMove],\r\n            };\r\n          }\r\n          return track;\r\n        })\r\n        .filter((track) => track.elements.length > 0);\r\n\r\n      updateTracksAndSave(newTracks);\r\n    },\r\n\r\n    updateElementTrim: (\r\n      trackId,\r\n      elementId,\r\n      trimStart,\r\n      trimEnd,\r\n      pushHistory = true\r\n    ) => {\r\n      if (pushHistory) get().pushHistory();\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((element) =>\r\n                  element.id === elementId\r\n                    ? { ...element, trimStart, trimEnd }\r\n                    : element\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    updateElementDuration: (\r\n      trackId,\r\n      elementId,\r\n      duration,\r\n      pushHistory = true\r\n    ) => {\r\n      if (pushHistory) get().pushHistory();\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((element) =>\r\n                  element.id === elementId ? { ...element, duration } : element\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    updateElementStartTime: (\r\n      trackId,\r\n      elementId,\r\n      startTime,\r\n      pushHistory = true\r\n    ) => {\r\n      if (pushHistory) get().pushHistory();\r\n      const clampedStartTime = Math.max(0, startTime);\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((element) =>\r\n                  element.id === elementId\r\n                    ? { ...element, startTime: clampedStartTime }\r\n                    : element\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    updateElementStartTimeWithRipple: (trackId, elementId, newStartTime) => {\r\n      const { _tracks, rippleEditingEnabled } = get();\r\n\r\n      if (!rippleEditingEnabled) {\r\n        // If ripple editing is disabled, use regular update\r\n        get().updateElementStartTime(trackId, elementId, newStartTime);\r\n        return;\r\n      }\r\n\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((e) => e.id === elementId);\r\n\r\n      if (!element || !track) return;\r\n\r\n      get().pushHistory();\r\n\r\n      const oldStartTime = element.startTime;\r\n      const oldEndTime =\r\n        element.startTime +\r\n        (element.duration - element.trimStart - element.trimEnd);\r\n      const newEndTime =\r\n        newStartTime + (element.duration - element.trimStart - element.trimEnd);\r\n      const timeDelta = newStartTime - oldStartTime;\r\n\r\n      // Update tracks based on multi-track ripple setting\r\n      const updatedTracks = _tracks.map((currentTrack) => {\r\n        // Only apply ripple effects to the same track unless multi-track ripple is enabled\r\n        const shouldApplyRipple = currentTrack.id === trackId;\r\n\r\n        const updatedElements = currentTrack.elements.map((currentElement) => {\r\n          if (currentElement.id === elementId && currentTrack.id === trackId) {\r\n            return { ...currentElement, startTime: Math.max(0, newStartTime) };\r\n          }\r\n\r\n          // Only apply ripple effects if we should process this track\r\n          if (!shouldApplyRipple) {\r\n            return currentElement;\r\n          }\r\n\r\n          // For ripple editing, we need to move elements that come after the moved element\r\n          const currentElementStart = currentElement.startTime;\r\n          const currentElementEnd =\r\n            currentElement.startTime +\r\n            (currentElement.duration -\r\n              currentElement.trimStart -\r\n              currentElement.trimEnd);\r\n\r\n          // If moving element to the right (positive delta)\r\n          if (timeDelta > 0) {\r\n            // Move elements that start after the original position of the moved element\r\n            if (currentElementStart >= oldEndTime) {\r\n              return {\r\n                ...currentElement,\r\n                startTime: currentElementStart + timeDelta,\r\n              };\r\n            }\r\n          }\r\n          // If moving element to the left (negative delta)\r\n          else if (timeDelta < 0) {\r\n            // Move elements that start after the new position of the moved element\r\n            if (\r\n              currentElementStart >= newEndTime &&\r\n              currentElementStart >= oldStartTime\r\n            ) {\r\n              return {\r\n                ...currentElement,\r\n                startTime: Math.max(0, currentElementStart + timeDelta),\r\n              };\r\n            }\r\n          }\r\n\r\n          return currentElement;\r\n        });\r\n\r\n        // Check for overlaps and resolve them if necessary\r\n        const hasOverlaps = checkElementOverlaps(updatedElements);\r\n        if (hasOverlaps) {\r\n          // Resolve overlaps by adjusting element positions\r\n          const resolvedElements = resolveElementOverlaps(updatedElements);\r\n          return { ...currentTrack, elements: resolvedElements };\r\n        }\r\n\r\n        return { ...currentTrack, elements: updatedElements };\r\n      });\r\n\r\n      updateTracksAndSave(updatedTracks);\r\n    },\r\n\r\n    toggleTrackMute: (trackId) => {\r\n      get().pushHistory();\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId ? { ...track, muted: !track.muted } : track\r\n        )\r\n      );\r\n    },\r\n\r\n    toggleElementHidden: (trackId, elementId) => {\r\n      get().pushHistory();\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((element) =>\r\n                  element.id === elementId\r\n                    ? { ...element, hidden: !element.hidden }\r\n                    : element\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    updateTextElement: (trackId, elementId, updates) => {\r\n      get().pushHistory();\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((element) =>\r\n                  element.id === elementId && element.type === \"text\"\r\n                    ? { ...element, ...updates }\r\n                    : element\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    splitElement: (trackId, elementId, splitTime) => {\r\n      const { _tracks } = get();\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((c) => c.id === elementId);\r\n\r\n      if (!element) return null;\r\n\r\n      const effectiveStart = element.startTime;\r\n      const effectiveEnd =\r\n        element.startTime +\r\n        (element.duration - element.trimStart - element.trimEnd);\r\n\r\n      if (splitTime <= effectiveStart || splitTime >= effectiveEnd) return null;\r\n\r\n      get().pushHistory();\r\n\r\n      const relativeTime = splitTime - element.startTime;\r\n      const firstDuration = relativeTime;\r\n      const secondDuration =\r\n        element.duration - element.trimStart - element.trimEnd - relativeTime;\r\n\r\n      const secondElementId = generateUUID();\r\n\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.flatMap((c) =>\r\n                  c.id === elementId\r\n                    ? [\r\n                        {\r\n                          ...c,\r\n                          trimEnd: c.trimEnd + secondDuration,\r\n                          name: getElementNameWithSuffix(c.name, \"left\"),\r\n                        },\r\n                        {\r\n                          ...c,\r\n                          id: secondElementId,\r\n                          startTime: splitTime,\r\n                          trimStart: c.trimStart + firstDuration,\r\n                          name: getElementNameWithSuffix(c.name, \"right\"),\r\n                        },\r\n                      ]\r\n                    : [c]\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n\r\n      return secondElementId;\r\n    },\r\n\r\n    // Split element and keep only the left portion\r\n    splitAndKeepLeft: (trackId, elementId, splitTime) => {\r\n      const { _tracks } = get();\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((c) => c.id === elementId);\r\n\r\n      if (!element) return;\r\n\r\n      const effectiveStart = element.startTime;\r\n      const effectiveEnd =\r\n        element.startTime +\r\n        (element.duration - element.trimStart - element.trimEnd);\r\n\r\n      if (splitTime <= effectiveStart || splitTime >= effectiveEnd) return;\r\n\r\n      get().pushHistory();\r\n\r\n      const relativeTime = splitTime - element.startTime;\r\n      const durationToRemove =\r\n        element.duration - element.trimStart - element.trimEnd - relativeTime;\r\n\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((c) =>\r\n                  c.id === elementId\r\n                    ? {\r\n                        ...c,\r\n                        trimEnd: c.trimEnd + durationToRemove,\r\n                        name: getElementNameWithSuffix(c.name, \"left\"),\r\n                      }\r\n                    : c\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    // Split element and keep only the right portion\r\n    splitAndKeepRight: (trackId, elementId, splitTime) => {\r\n      const { _tracks } = get();\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((c) => c.id === elementId);\r\n\r\n      if (!element) return;\r\n\r\n      const effectiveStart = element.startTime;\r\n      const effectiveEnd =\r\n        element.startTime +\r\n        (element.duration - element.trimStart - element.trimEnd);\r\n\r\n      if (splitTime <= effectiveStart || splitTime >= effectiveEnd) return;\r\n\r\n      get().pushHistory();\r\n\r\n      const relativeTime = splitTime - element.startTime;\r\n\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((c) =>\r\n                  c.id === elementId\r\n                    ? {\r\n                        ...c,\r\n                        startTime: splitTime,\r\n                        trimStart: c.trimStart + relativeTime,\r\n                        name: getElementNameWithSuffix(c.name, \"right\"),\r\n                      }\r\n                    : c\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    // Extract audio from video element to an audio track\r\n    separateAudio: (trackId, elementId) => {\r\n      const { _tracks } = get();\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((c) => c.id === elementId);\r\n\r\n      if (!element || track?.type !== \"media\") return null;\r\n\r\n      get().pushHistory();\r\n\r\n      // Find existing audio track or prepare to create one\r\n      const existingAudioTrack = _tracks.find((t) => t.type === \"audio\");\r\n      const audioElementId = generateUUID();\r\n\r\n      if (existingAudioTrack) {\r\n        // Add audio element to existing audio track\r\n        updateTracksAndSave(\r\n          get()._tracks.map((track) =>\r\n            track.id === existingAudioTrack.id\r\n              ? {\r\n                  ...track,\r\n                  elements: [\r\n                    ...track.elements,\r\n                    {\r\n                      ...element,\r\n                      id: audioElementId,\r\n                      name: getElementNameWithSuffix(element.name, \"audio\"),\r\n                    },\r\n                  ],\r\n                }\r\n              : track\r\n          )\r\n        );\r\n      } else {\r\n        // Create new audio track with the audio element in a single atomic update\r\n        const newAudioTrack: TimelineTrack = {\r\n          id: generateUUID(),\r\n          name: \"Audio Track\",\r\n          type: \"audio\",\r\n          elements: [\r\n            {\r\n              ...element,\r\n              id: audioElementId,\r\n              name: getElementNameWithSuffix(element.name, \"audio\"),\r\n            },\r\n          ],\r\n          muted: false,\r\n        };\r\n\r\n        updateTracksAndSave([...get()._tracks, newAudioTrack]);\r\n      }\r\n\r\n      return audioElementId;\r\n    },\r\n\r\n    // Replace media for an element\r\n    replaceElementMedia: async (\r\n      trackId: string,\r\n      elementId: string,\r\n      newFile: File\r\n    ): Promise<{ success: boolean; error?: string }> => {\r\n      const { _tracks } = get();\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((c) => c.id === elementId);\r\n\r\n      if (!element) {\r\n        return { success: false, error: \"Timeline element not found\" };\r\n      }\r\n\r\n      if (element.type !== \"media\") {\r\n        return {\r\n          success: false,\r\n          error: \"Replace is only available for media clips\",\r\n        };\r\n      }\r\n\r\n      try {\r\n        const mediaStore = useMediaStore.getState();\r\n        const projectStore = useProjectStore.getState();\r\n\r\n        if (!projectStore.activeProject) {\r\n          return { success: false, error: \"No active project found\" };\r\n        }\r\n\r\n        // Import required media processing functions\r\n        const {\r\n          getFileType,\r\n          getImageDimensions,\r\n          generateVideoThumbnail,\r\n          getMediaDuration,\r\n        } = await import(\"./media-store\");\r\n\r\n        const fileType = getFileType(newFile);\r\n        if (!fileType) {\r\n          return {\r\n            success: false,\r\n            error:\r\n              \"Unsupported file type. Please select a video, audio, or image file.\",\r\n          };\r\n        }\r\n\r\n        // Process the new media file\r\n        const mediaData: any = {\r\n          name: newFile.name,\r\n          type: fileType,\r\n          file: newFile,\r\n          url: URL.createObjectURL(newFile),\r\n        };\r\n\r\n        try {\r\n          // Get media-specific metadata\r\n          if (fileType === \"image\") {\r\n            const { width, height } = await getImageDimensions(newFile);\r\n            mediaData.width = width;\r\n            mediaData.height = height;\r\n          } else if (fileType === \"video\") {\r\n            const [duration, { thumbnailUrl, width, height }] =\r\n              await Promise.all([\r\n                getMediaDuration(newFile),\r\n                generateVideoThumbnail(newFile),\r\n              ]);\r\n            mediaData.duration = duration;\r\n            mediaData.thumbnailUrl = thumbnailUrl;\r\n            mediaData.width = width;\r\n            mediaData.height = height;\r\n          } else if (fileType === \"audio\") {\r\n            mediaData.duration = await getMediaDuration(newFile);\r\n          }\r\n        } catch (error) {\r\n          return {\r\n            success: false,\r\n            error: `Failed to process ${fileType} file: ${error instanceof Error ? error.message : \"Unknown error\"}`,\r\n          };\r\n        }\r\n\r\n        // Add new media item to store\r\n        try {\r\n          await mediaStore.addMediaItem(\r\n            projectStore.activeProject.id,\r\n            mediaData\r\n          );\r\n        } catch (error) {\r\n          return {\r\n            success: false,\r\n            error: `Failed to add media to project: ${error instanceof Error ? error.message : \"Unknown error\"}`,\r\n          };\r\n        }\r\n\r\n        // Find the newly created media item\r\n        const newMediaItem = mediaStore.mediaItems.find(\r\n          (item) => item.file === newFile\r\n        );\r\n\r\n        if (!newMediaItem) {\r\n          return {\r\n            success: false,\r\n            error: \"Failed to create media item in project. Please try again.\",\r\n          };\r\n        }\r\n\r\n        get().pushHistory();\r\n\r\n        // Update the timeline element to reference the new media\r\n        updateTracksAndSave(\r\n          _tracks.map((track) =>\r\n            track.id === trackId\r\n              ? {\r\n                  ...track,\r\n                  elements: track.elements.map((c) =>\r\n                    c.id === elementId\r\n                      ? {\r\n                          ...c,\r\n                          mediaId: newMediaItem.id,\r\n                          name: newMediaItem.name,\r\n                          // Update duration if the new media has a different duration\r\n                          duration: newMediaItem.duration || c.duration,\r\n                        }\r\n                      : c\r\n                  ),\r\n                }\r\n              : track\r\n          )\r\n        );\r\n\r\n        return { success: true };\r\n      } catch (error) {\r\n        console.error(\"Failed to replace element media:\", error);\r\n        return {\r\n          success: false,\r\n          error: `Unexpected error: ${error instanceof Error ? error.message : \"Unknown error\"}`,\r\n        };\r\n      }\r\n    },\r\n\r\n    getTotalDuration: () => {\r\n      const { _tracks } = get();\r\n      if (_tracks.length === 0) return 0;\r\n\r\n      const trackEndTimes = _tracks.map((track) =>\r\n        track.elements.reduce((maxEnd, element) => {\r\n          const elementEnd =\r\n            element.startTime +\r\n            element.duration -\r\n            element.trimStart -\r\n            element.trimEnd;\r\n          return Math.max(maxEnd, elementEnd);\r\n        }, 0)\r\n      );\r\n\r\n      return Math.max(...trackEndTimes, 0);\r\n    },\r\n\r\n    getProjectThumbnail: async (projectId) => {\r\n      try {\r\n        const tracks = await storageService.loadTimeline(projectId);\r\n        const mediaItems = await storageService.loadAllMediaItems(projectId);\r\n\r\n        if (!tracks || !mediaItems.length) return null;\r\n\r\n        const firstMediaElement = tracks\r\n          .flatMap((track) => track.elements)\r\n          .filter((element) => element.type === \"media\")\r\n          .sort((a, b) => a.startTime - b.startTime)[0];\r\n\r\n        if (!firstMediaElement) return null;\r\n\r\n        const mediaItem = mediaItems.find(\r\n          (item) => item.id === firstMediaElement.mediaId\r\n        );\r\n        if (!mediaItem) return null;\r\n\r\n        if (mediaItem.type === \"video\" && mediaItem.file) {\r\n          const { generateVideoThumbnail } = await import(\r\n            \"@/stores/media-store\"\r\n          );\r\n          const { thumbnailUrl } = await generateVideoThumbnail(mediaItem.file);\r\n          return thumbnailUrl;\r\n        }\r\n        if (mediaItem.type === \"image\" && mediaItem.url) {\r\n          return mediaItem.url;\r\n        }\r\n\r\n        return null;\r\n      } catch (error) {\r\n        console.error(\"Failed to get project thumbnail:\", error);\r\n        return null;\r\n      }\r\n    },\r\n\r\n    redo: () => {\r\n      const { redoStack } = get();\r\n      if (redoStack.length === 0) return;\r\n      const next = redoStack[redoStack.length - 1];\r\n      updateTracksAndSave(next);\r\n      set({ redoStack: redoStack.slice(0, -1) });\r\n    },\r\n\r\n    dragState: {\r\n      isDragging: false,\r\n      elementId: null,\r\n      trackId: null,\r\n      startMouseX: 0,\r\n      startElementTime: 0,\r\n      clickOffsetTime: 0,\r\n      currentTime: 0,\r\n    },\r\n\r\n    setDragState: (dragState) =>\r\n      set((state) => ({\r\n        dragState: { ...state.dragState, ...dragState },\r\n      })),\r\n\r\n    startDrag: (\r\n      elementId,\r\n      trackId,\r\n      startMouseX,\r\n      startElementTime,\r\n      clickOffsetTime\r\n    ) => {\r\n      set({\r\n        dragState: {\r\n          isDragging: true,\r\n          elementId,\r\n          trackId,\r\n          startMouseX,\r\n          startElementTime,\r\n          clickOffsetTime,\r\n          currentTime: startElementTime,\r\n        },\r\n      });\r\n    },\r\n\r\n    updateDragTime: (currentTime) => {\r\n      set((state) => ({\r\n        dragState: {\r\n          ...state.dragState,\r\n          currentTime,\r\n        },\r\n      }));\r\n    },\r\n\r\n    endDrag: () => {\r\n      set({\r\n        dragState: {\r\n          isDragging: false,\r\n          elementId: null,\r\n          trackId: null,\r\n          startMouseX: 0,\r\n          startElementTime: 0,\r\n          clickOffsetTime: 0,\r\n          currentTime: 0,\r\n        },\r\n      });\r\n    },\r\n\r\n    // Persistence methods\r\n    loadProjectTimeline: async (projectId) => {\r\n      try {\r\n        const tracks = await storageService.loadTimeline(projectId);\r\n        if (tracks) {\r\n          updateTracks(tracks);\r\n        } else {\r\n          // No timeline saved yet, initialize with default\r\n          const defaultTracks = ensureMainTrack([]);\r\n          updateTracks(defaultTracks);\r\n        }\r\n        // Clear history when loading a project\r\n        set({ history: [], redoStack: [] });\r\n      } catch (error) {\r\n        console.error(\"Failed to load timeline:\", error);\r\n        // Initialize with default on error\r\n        const defaultTracks = ensureMainTrack([]);\r\n        updateTracks(defaultTracks);\r\n        set({ history: [], redoStack: [] });\r\n      }\r\n    },\r\n\r\n    saveProjectTimeline: async (projectId) => {\r\n      try {\r\n        await storageService.saveTimeline(projectId, get()._tracks);\r\n      } catch (error) {\r\n        console.error(\"Failed to save timeline:\", error);\r\n      }\r\n    },\r\n\r\n    clearTimeline: () => {\r\n      const defaultTracks = ensureMainTrack([]);\r\n      updateTracks(defaultTracks);\r\n      set({ history: [], redoStack: [], selectedElements: [] });\r\n    },\r\n\r\n    // Snapping actions\r\n    toggleSnapping: () => {\r\n      set((state) => ({ snappingEnabled: !state.snappingEnabled }));\r\n    },\r\n\r\n    // Ripple editing functions\r\n    toggleRippleEditing: () => {\r\n      set((state) => ({\r\n        rippleEditingEnabled: !state.rippleEditingEnabled,\r\n      }));\r\n    },\r\n\r\n    checkElementOverlap: (trackId, startTime, duration, excludeElementId) => {\r\n      const track = get()._tracks.find((t) => t.id === trackId);\r\n      if (!track) return false;\r\n\r\n      const overlap = track.elements.some((element) => {\r\n        const elementEnd =\r\n          element.startTime +\r\n          element.duration -\r\n          element.trimStart -\r\n          element.trimEnd;\r\n\r\n        if (element.id === excludeElementId) {\r\n          return false;\r\n        }\r\n\r\n        return (\r\n          (startTime >= element.startTime && startTime < elementEnd) ||\r\n          (startTime + duration > element.startTime &&\r\n            startTime + duration <= elementEnd) ||\r\n          (startTime < element.startTime && startTime + duration > elementEnd)\r\n        );\r\n      });\r\n      return overlap;\r\n    },\r\n\r\n    findOrCreateTrack: (trackType) => {\r\n      // Always create new text track to allow multiple text elements\r\n      // Insert text tracks at the top\r\n      if (trackType === \"text\") {\r\n        return get().insertTrackAt(trackType, 0);\r\n      }\r\n\r\n      const existingTrack = get()._tracks.find((t) => t.type === trackType);\r\n      if (existingTrack) {\r\n        return existingTrack.id;\r\n      }\r\n\r\n      return get().addTrack(trackType);\r\n    },\r\n\r\n    addMediaAtTime: (item, currentTime = 0) => {\r\n      const trackType = item.type === \"audio\" ? \"audio\" : \"media\";\r\n      const duration =\r\n        item.duration || TIMELINE_CONSTANTS.DEFAULT_IMAGE_DURATION;\r\n\r\n      // Get all tracks of the right type\r\n      const tracks = get()._tracks.filter((t) => t.type === trackType);\r\n\r\n      // Try to find a track with no overlap\r\n      let targetTrackId = null;\r\n      for (const track of tracks) {\r\n        if (!get().checkElementOverlap(track.id, currentTime, duration)) {\r\n          targetTrackId = track.id;\r\n          break;\r\n        }\r\n      }\r\n\r\n      // If no free track found, create a new one\r\n      if (!targetTrackId) {\r\n        targetTrackId = get().addTrack(trackType);\r\n      }\r\n\r\n      get().addElementToTrack(targetTrackId, {\r\n        type: \"media\",\r\n        mediaId: item.id,\r\n        name: item.name,\r\n        duration,\r\n        startTime: currentTime,\r\n        trimStart: 0,\r\n        trimEnd: 0,\r\n      });\r\n      return true;\r\n    },\r\n\r\n    addTextAtTime: (item, currentTime = 0) => {\r\n      const targetTrackId = get().insertTrackAt(\"text\", 0); // Always create new text track at the top\r\n\r\n      get().addElementToTrack(targetTrackId, {\r\n        type: \"text\",\r\n        name: item.name || \"Text\",\r\n        content: item.content || \"Default Text\",\r\n        duration: item.duration || TIMELINE_CONSTANTS.DEFAULT_TEXT_DURATION,\r\n        startTime: currentTime,\r\n        trimStart: 0,\r\n        trimEnd: 0,\r\n        fontSize: item.fontSize || 48,\r\n        fontFamily: item.fontFamily || \"Arial\",\r\n        color: item.color || \"#ffffff\",\r\n        backgroundColor: item.backgroundColor || \"transparent\",\r\n        textAlign: item.textAlign || \"center\",\r\n        fontWeight: item.fontWeight || \"normal\",\r\n        fontStyle: item.fontStyle || \"normal\",\r\n        textDecoration: item.textDecoration || \"none\",\r\n        x: item.x || 0,\r\n        y: item.y || 0,\r\n        rotation: item.rotation || 0,\r\n        opacity: item.opacity !== undefined ? item.opacity : 1,\r\n      });\r\n      return true;\r\n    },\r\n\r\n    addMediaToNewTrack: (item) => {\r\n      const trackType = item.type === \"audio\" ? \"audio\" : \"media\";\r\n      const targetTrackId = get().findOrCreateTrack(trackType);\r\n\r\n      get().addElementToTrack(targetTrackId, {\r\n        type: \"media\",\r\n        mediaId: item.id,\r\n        name: item.name,\r\n        duration: item.duration || TIMELINE_CONSTANTS.DEFAULT_IMAGE_DURATION,\r\n        startTime: 0,\r\n        trimStart: 0,\r\n        trimEnd: 0,\r\n      });\r\n      return true;\r\n    },\r\n\r\n    addTextToNewTrack: (item) => {\r\n      const targetTrackId = get().insertTrackAt(\"text\", 0); // Always create new text track at the top\r\n\r\n      get().addElementToTrack(targetTrackId, {\r\n        type: \"text\",\r\n        name: item.name || \"Text\",\r\n        content:\r\n          (\"content\" in item ? item.content : \"Default Text\") || \"Default Text\",\r\n        duration: TIMELINE_CONSTANTS.DEFAULT_TEXT_DURATION,\r\n        startTime: 0,\r\n        trimStart: 0,\r\n        trimEnd: 0,\r\n        fontSize: (\"fontSize\" in item ? item.fontSize : 48) || 48,\r\n        fontFamily:\r\n          (\"fontFamily\" in item ? item.fontFamily : \"Arial\") || \"Arial\",\r\n        color: (\"color\" in item ? item.color : \"#ffffff\") || \"#ffffff\",\r\n        backgroundColor:\r\n          (\"backgroundColor\" in item ? item.backgroundColor : \"transparent\") ||\r\n          \"transparent\",\r\n        textAlign:\r\n          (\"textAlign\" in item ? item.textAlign : \"center\") || \"center\",\r\n        fontWeight:\r\n          (\"fontWeight\" in item ? item.fontWeight : \"normal\") || \"normal\",\r\n        fontStyle:\r\n          (\"fontStyle\" in item ? item.fontStyle : \"normal\") || \"normal\",\r\n        textDecoration:\r\n          (\"textDecoration\" in item ? item.textDecoration : \"none\") || \"none\",\r\n        x: (\"x\" in item ? item.x : 0) || 0,\r\n        y: (\"y\" in item ? item.y : 0) || 0,\r\n        rotation: (\"rotation\" in item ? item.rotation : 0) || 0,\r\n        opacity:\r\n          \"opacity\" in item && item.opacity !== undefined ? item.opacity : 1,\r\n      });\r\n      return true;\r\n    },\r\n  };\r\n});\r\n","import { MediaType } from \"@/stores/media-store\";\r\nimport { generateUUID } from \"@/lib/utils\";\r\n\r\nexport type TrackType = \"media\" | \"text\" | \"audio\";\r\n\r\n// Base element properties\r\ninterface BaseTimelineElement {\r\n  id: string;\r\n  name: string;\r\n  duration: number;\r\n  startTime: number;\r\n  trimStart: number;\r\n  trimEnd: number;\r\n  hidden?: boolean;\r\n}\r\n\r\n// Media element that references MediaStore\r\nexport interface MediaElement extends BaseTimelineElement {\r\n  type: \"media\";\r\n  mediaId: string;\r\n}\r\n\r\n// Text element with embedded text data\r\nexport interface TextElement extends BaseTimelineElement {\r\n  type: \"text\";\r\n  content: string;\r\n  fontSize: number;\r\n  fontFamily: string;\r\n  color: string;\r\n  backgroundColor: string;\r\n  textAlign: \"left\" | \"center\" | \"right\";\r\n  fontWeight: \"normal\" | \"bold\";\r\n  fontStyle: \"normal\" | \"italic\";\r\n  textDecoration: \"none\" | \"underline\" | \"line-through\";\r\n  x: number; // Position relative to canvas center\r\n  y: number; // Position relative to canvas center\r\n  rotation: number; // in degrees\r\n  opacity: number; // 0-1\r\n}\r\n\r\n// Typed timeline elements\r\nexport type TimelineElement = MediaElement | TextElement;\r\n\r\n// Creation types (without id, for addElementToTrack)\r\nexport type CreateMediaElement = Omit<MediaElement, \"id\">;\r\nexport type CreateTextElement = Omit<TextElement, \"id\">;\r\nexport type CreateTimelineElement = CreateMediaElement | CreateTextElement;\r\n\r\nexport interface TimelineElementProps {\r\n  element: TimelineElement;\r\n  track: TimelineTrack;\r\n  zoomLevel: number;\r\n  isSelected: boolean;\r\n  onElementMouseDown: (e: React.MouseEvent, element: TimelineElement) => void;\r\n  onElementClick: (e: React.MouseEvent, element: TimelineElement) => void;\r\n}\r\n\r\nexport interface ResizeState {\r\n  elementId: string;\r\n  side: \"left\" | \"right\";\r\n  startX: number;\r\n  initialTrimStart: number;\r\n  initialTrimEnd: number;\r\n}\r\n\r\n// Drag data types for type-safe drag and drop\r\nexport interface MediaItemDragData {\r\n  id: string;\r\n  type: MediaType;\r\n  name: string;\r\n}\r\n\r\nexport interface TextItemDragData {\r\n  id: string;\r\n  type: \"text\";\r\n  name: string;\r\n  content: string;\r\n}\r\n\r\nexport type DragData = MediaItemDragData | TextItemDragData;\r\n\r\nexport interface TimelineTrack {\r\n  id: string;\r\n  name: string;\r\n  type: TrackType;\r\n  elements: TimelineElement[];\r\n  muted?: boolean;\r\n  isMain?: boolean;\r\n}\r\n\r\nexport function sortTracksByOrder(tracks: TimelineTrack[]): TimelineTrack[] {\r\n  return [...tracks].sort((a, b) => {\r\n    // Text tracks always go to the top\r\n    if (a.type === \"text\" && b.type !== \"text\") return -1;\r\n    if (b.type === \"text\" && a.type !== \"text\") return 1;\r\n\r\n    // Audio tracks always go to bottom\r\n    if (a.type === \"audio\" && b.type !== \"audio\") return 1;\r\n    if (b.type === \"audio\" && a.type !== \"audio\") return -1;\r\n\r\n    // Main track goes above audio but below text tracks\r\n    if (a.isMain && !b.isMain && b.type !== \"audio\" && b.type !== \"text\")\r\n      return 1;\r\n    if (b.isMain && !a.isMain && a.type !== \"audio\" && a.type !== \"text\")\r\n      return -1;\r\n\r\n    // Within same category, maintain creation order\r\n    return 0;\r\n  });\r\n}\r\n\r\nexport function getMainTrack(tracks: TimelineTrack[]): TimelineTrack | null {\r\n  return tracks.find((track) => track.isMain) || null;\r\n}\r\n\r\nexport function ensureMainTrack(tracks: TimelineTrack[]): TimelineTrack[] {\r\n  const hasMainTrack = tracks.some((track) => track.isMain);\r\n\r\n  if (!hasMainTrack) {\r\n    // Create main track if it doesn't exist\r\n    const mainTrack: TimelineTrack = {\r\n      id: generateUUID(),\r\n      name: \"Main Track\",\r\n      type: \"media\",\r\n      elements: [],\r\n      muted: false,\r\n      isMain: true,\r\n    };\r\n    return [mainTrack, ...tracks];\r\n  }\r\n\r\n  return tracks;\r\n}\r\n\r\n// Timeline validation utilities\r\nexport function canElementGoOnTrack(\r\n  elementType: \"text\" | \"media\",\r\n  trackType: TrackType\r\n): boolean {\r\n  if (elementType === \"text\") {\r\n    return trackType === \"text\";\r\n  }\r\n  if (elementType === \"media\") {\r\n    return trackType === \"media\" || trackType === \"audio\";\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function validateElementTrackCompatibility(\r\n  element: { type: \"text\" | \"media\" },\r\n  track: { type: TrackType }\r\n): { isValid: boolean; errorMessage?: string } {\r\n  const isValid = canElementGoOnTrack(element.type, track.type);\r\n\r\n  if (!isValid) {\r\n    const errorMessage =\r\n      element.type === \"text\"\r\n        ? \"Text elements can only be placed on text tracks\"\r\n        : \"Media elements can only be placed on media or audio tracks\";\r\n\r\n    return { isValid: false, errorMessage };\r\n  }\r\n\r\n  return { isValid: true };\r\n}\r\n","import { StorageAdapter } from \"./types\";\r\n\r\nexport class IndexedDBAdapter<T> implements StorageAdapter<T> {\r\n  private dbName: string;\r\n  private storeName: string;\r\n  private version: number;\r\n\r\n  constructor(dbName: string, storeName: string, version = 1) {\r\n    this.dbName = dbName;\r\n    this.storeName = storeName;\r\n    this.version = version;\r\n  }\r\n\r\n  private async getDB(): Promise<IDBDatabase> {\r\n    return new Promise((resolve, reject) => {\r\n      const request = indexedDB.open(this.dbName, this.version);\r\n\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve(request.result);\r\n\r\n      request.onupgradeneeded = (event) => {\r\n        const db = (event.target as IDBOpenDBRequest).result;\r\n        if (!db.objectStoreNames.contains(this.storeName)) {\r\n          db.createObjectStore(this.storeName, { keyPath: \"id\" });\r\n        }\r\n      };\r\n    });\r\n  }\r\n\r\n  async get(key: string): Promise<T | null> {\r\n    const db = await this.getDB();\r\n    const transaction = db.transaction([this.storeName], \"readonly\");\r\n    const store = transaction.objectStore(this.storeName);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = store.get(key);\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve(request.result || null);\r\n    });\r\n  }\r\n\r\n  async set(key: string, value: T): Promise<void> {\r\n    const db = await this.getDB();\r\n    const transaction = db.transaction([this.storeName], \"readwrite\");\r\n    const store = transaction.objectStore(this.storeName);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = store.put({ id: key, ...value });\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve();\r\n    });\r\n  }\r\n\r\n  async remove(key: string): Promise<void> {\r\n    const db = await this.getDB();\r\n    const transaction = db.transaction([this.storeName], \"readwrite\");\r\n    const store = transaction.objectStore(this.storeName);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = store.delete(key);\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve();\r\n    });\r\n  }\r\n\r\n  async list(): Promise<string[]> {\r\n    const db = await this.getDB();\r\n    const transaction = db.transaction([this.storeName], \"readonly\");\r\n    const store = transaction.objectStore(this.storeName);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = store.getAllKeys();\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve(request.result as string[]);\r\n    });\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    const db = await this.getDB();\r\n    const transaction = db.transaction([this.storeName], \"readwrite\");\r\n    const store = transaction.objectStore(this.storeName);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = store.clear();\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve();\r\n    });\r\n  }\r\n}\r\n","import { StorageAdapter } from \"./types\";\r\n\r\nexport class OPFSAdapter implements StorageAdapter<File> {\r\n  private directoryName: string;\r\n\r\n  constructor(directoryName = \"media\") {\r\n    this.directoryName = directoryName;\r\n  }\r\n\r\n  private async getDirectory(): Promise<FileSystemDirectoryHandle> {\r\n    const opfsRoot = await navigator.storage.getDirectory();\r\n    return await opfsRoot.getDirectoryHandle(this.directoryName, {\r\n      create: true,\r\n    });\r\n  }\r\n\r\n  async get(key: string): Promise<File | null> {\r\n    try {\r\n      const directory = await this.getDirectory();\r\n      const fileHandle = await directory.getFileHandle(key);\r\n      return await fileHandle.getFile();\r\n    } catch (error) {\r\n      if ((error as Error).name === \"NotFoundError\") {\r\n        return null;\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async set(key: string, file: File): Promise<void> {\r\n    const directory = await this.getDirectory();\r\n    const fileHandle = await directory.getFileHandle(key, { create: true });\r\n    const writable = await fileHandle.createWritable();\r\n\r\n    await writable.write(file);\r\n    await writable.close();\r\n  }\r\n\r\n  async remove(key: string): Promise<void> {\r\n    try {\r\n      const directory = await this.getDirectory();\r\n      await directory.removeEntry(key);\r\n    } catch (error) {\r\n      if ((error as Error).name !== \"NotFoundError\") {\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n\r\n  async list(): Promise<string[]> {\r\n    const directory = await this.getDirectory();\r\n    const keys: string[] = [];\r\n\r\n    for await (const name of directory.keys()) {\r\n      keys.push(name);\r\n    }\r\n\r\n    return keys;\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    const directory = await this.getDirectory();\r\n\r\n    for await (const name of directory.keys()) {\r\n      await directory.removeEntry(name);\r\n    }\r\n  }\r\n\r\n  // Helper method to check OPFS support\r\n  static isSupported(): boolean {\r\n    return \"storage\" in navigator && \"getDirectory\" in navigator.storage;\r\n  }\r\n}\r\n","import { TProject } from \"@/types/project\";\r\nimport { MediaItem } from \"@/stores/media-store\";\r\nimport { IndexedDBAdapter } from \"./indexeddb-adapter\";\r\nimport { OPFSAdapter } from \"./opfs-adapter\";\r\nimport {\r\n  MediaFileData,\r\n  StorageConfig,\r\n  SerializedProject,\r\n  TimelineData,\r\n} from \"./types\";\r\nimport { TimelineTrack } from \"@/types/timeline\";\r\nimport { SavedSoundsData, SavedSound, SoundEffect } from \"@/types/sounds\";\r\n\r\nclass StorageService {\r\n  private projectsAdapter: IndexedDBAdapter<SerializedProject>;\r\n  private savedSoundsAdapter: IndexedDBAdapter<SavedSoundsData>;\r\n  private config: StorageConfig;\r\n\r\n  constructor() {\r\n    this.config = {\r\n      projectsDb: \"video-editor-projects\",\r\n      mediaDb: \"video-editor-media\",\r\n      timelineDb: \"video-editor-timelines\",\r\n      savedSoundsDb: \"video-editor-saved-sounds\",\r\n      version: 1,\r\n    };\r\n\r\n    this.projectsAdapter = new IndexedDBAdapter<SerializedProject>(\r\n      this.config.projectsDb,\r\n      \"projects\",\r\n      this.config.version\r\n    );\r\n\r\n    this.savedSoundsAdapter = new IndexedDBAdapter<SavedSoundsData>(\r\n      this.config.savedSoundsDb,\r\n      \"saved-sounds\",\r\n      this.config.version\r\n    );\r\n  }\r\n\r\n  // Helper to get project-specific media adapters\r\n  private getProjectMediaAdapters(projectId: string) {\r\n    const mediaMetadataAdapter = new IndexedDBAdapter<MediaFileData>(\r\n      `${this.config.mediaDb}-${projectId}`,\r\n      \"media-metadata\",\r\n      this.config.version\r\n    );\r\n\r\n    const mediaFilesAdapter = new OPFSAdapter(`media-files-${projectId}`);\r\n\r\n    return { mediaMetadataAdapter, mediaFilesAdapter };\r\n  }\r\n\r\n  // Helper to get project-specific timeline adapter\r\n  private getProjectTimelineAdapter(projectId: string) {\r\n    return new IndexedDBAdapter<TimelineData>(\r\n      `${this.config.timelineDb}-${projectId}`,\r\n      \"timeline\",\r\n      this.config.version\r\n    );\r\n  }\r\n\r\n  // Project operations\r\n  async saveProject(project: TProject): Promise<void> {\r\n    // Convert TProject to serializable format\r\n    const serializedProject: SerializedProject = {\r\n      id: project.id,\r\n      name: project.name,\r\n      thumbnail: project.thumbnail,\r\n      createdAt: project.createdAt.toISOString(),\r\n      updatedAt: project.updatedAt.toISOString(),\r\n      backgroundColor: project.backgroundColor,\r\n      backgroundType: project.backgroundType,\r\n      blurIntensity: project.blurIntensity,\r\n      bookmarks: project.bookmarks,\r\n      fps: project.fps,\r\n    };\r\n\r\n    await this.projectsAdapter.set(project.id, serializedProject);\r\n  }\r\n\r\n  async loadProject(id: string): Promise<TProject | null> {\r\n    const serializedProject = await this.projectsAdapter.get(id);\r\n\r\n    if (!serializedProject) return null;\r\n\r\n    // Convert back to TProject format\r\n    return {\r\n      id: serializedProject.id,\r\n      name: serializedProject.name,\r\n      thumbnail: serializedProject.thumbnail,\r\n      createdAt: new Date(serializedProject.createdAt),\r\n      updatedAt: new Date(serializedProject.updatedAt),\r\n      backgroundColor: serializedProject.backgroundColor,\r\n      backgroundType: serializedProject.backgroundType,\r\n      blurIntensity: serializedProject.blurIntensity,\r\n      bookmarks: serializedProject.bookmarks,\r\n      fps: serializedProject.fps,\r\n    };\r\n  }\r\n\r\n  async loadAllProjects(): Promise<TProject[]> {\r\n    const projectIds = await this.projectsAdapter.list();\r\n    const projects: TProject[] = [];\r\n\r\n    for (const id of projectIds) {\r\n      const project = await this.loadProject(id);\r\n      if (project) {\r\n        projects.push(project);\r\n      }\r\n    }\r\n\r\n    // Sort by last updated (most recent first)\r\n    return projects.sort(\r\n      (a, b) => b.updatedAt.getTime() - a.updatedAt.getTime()\r\n    );\r\n  }\r\n\r\n  async deleteProject(id: string): Promise<void> {\r\n    await this.projectsAdapter.remove(id);\r\n  }\r\n\r\n  // Media operations - now project-specific\r\n  async saveMediaItem(projectId: string, mediaItem: MediaItem): Promise<void> {\r\n    const { mediaMetadataAdapter, mediaFilesAdapter } =\r\n      this.getProjectMediaAdapters(projectId);\r\n\r\n    // Save file to project-specific OPFS\r\n    await mediaFilesAdapter.set(mediaItem.id, mediaItem.file);\r\n\r\n    // Save metadata to project-specific IndexedDB\r\n    const metadata: MediaFileData = {\r\n      id: mediaItem.id,\r\n      name: mediaItem.name,\r\n      type: mediaItem.type,\r\n      size: mediaItem.file.size,\r\n      lastModified: mediaItem.file.lastModified,\r\n      width: mediaItem.width,\r\n      height: mediaItem.height,\r\n      duration: mediaItem.duration,\r\n    };\r\n\r\n    await mediaMetadataAdapter.set(mediaItem.id, metadata);\r\n  }\r\n\r\n  async loadMediaItem(\r\n    projectId: string,\r\n    id: string\r\n  ): Promise<MediaItem | null> {\r\n    const { mediaMetadataAdapter, mediaFilesAdapter } =\r\n      this.getProjectMediaAdapters(projectId);\r\n\r\n    const [file, metadata] = await Promise.all([\r\n      mediaFilesAdapter.get(id),\r\n      mediaMetadataAdapter.get(id),\r\n    ]);\r\n\r\n    if (!file || !metadata) return null;\r\n\r\n    // Create new object URL for the file\r\n    const url = URL.createObjectURL(file);\r\n\r\n    return {\r\n      id: metadata.id,\r\n      name: metadata.name,\r\n      type: metadata.type,\r\n      file,\r\n      url,\r\n      width: metadata.width,\r\n      height: metadata.height,\r\n      duration: metadata.duration,\r\n      // thumbnailUrl would need to be regenerated or cached separately\r\n    };\r\n  }\r\n\r\n  async loadAllMediaItems(projectId: string): Promise<MediaItem[]> {\r\n    const { mediaMetadataAdapter } = this.getProjectMediaAdapters(projectId);\r\n\r\n    const mediaIds = await mediaMetadataAdapter.list();\r\n    const mediaItems: MediaItem[] = [];\r\n\r\n    for (const id of mediaIds) {\r\n      const item = await this.loadMediaItem(projectId, id);\r\n      if (item) {\r\n        mediaItems.push(item);\r\n      }\r\n    }\r\n\r\n    return mediaItems;\r\n  }\r\n\r\n  async deleteMediaItem(projectId: string, id: string): Promise<void> {\r\n    const { mediaMetadataAdapter, mediaFilesAdapter } =\r\n      this.getProjectMediaAdapters(projectId);\r\n\r\n    await Promise.all([\r\n      mediaFilesAdapter.remove(id),\r\n      mediaMetadataAdapter.remove(id),\r\n    ]);\r\n  }\r\n\r\n  async deleteProjectMedia(projectId: string): Promise<void> {\r\n    const { mediaMetadataAdapter, mediaFilesAdapter } =\r\n      this.getProjectMediaAdapters(projectId);\r\n\r\n    await Promise.all([\r\n      mediaMetadataAdapter.clear(),\r\n      mediaFilesAdapter.clear(),\r\n    ]);\r\n  }\r\n\r\n  // Timeline operations - now project-specific\r\n  async saveTimeline(\r\n    projectId: string,\r\n    tracks: TimelineTrack[]\r\n  ): Promise<void> {\r\n    const timelineAdapter = this.getProjectTimelineAdapter(projectId);\r\n    const timelineData: TimelineData = {\r\n      tracks,\r\n      lastModified: new Date().toISOString(),\r\n    };\r\n    await timelineAdapter.set(\"timeline\", timelineData);\r\n  }\r\n\r\n  async loadTimeline(projectId: string): Promise<TimelineTrack[] | null> {\r\n    const timelineAdapter = this.getProjectTimelineAdapter(projectId);\r\n    const timelineData = await timelineAdapter.get(\"timeline\");\r\n    return timelineData ? timelineData.tracks : null;\r\n  }\r\n\r\n  async deleteProjectTimeline(projectId: string): Promise<void> {\r\n    const timelineAdapter = this.getProjectTimelineAdapter(projectId);\r\n    await timelineAdapter.remove(\"timeline\");\r\n  }\r\n\r\n  // Utility methods\r\n  async clearAllData(): Promise<void> {\r\n    // Clear all projects\r\n    await this.projectsAdapter.clear();\r\n\r\n    // Note: Project-specific media and timelines will be cleaned up when projects are deleted\r\n  }\r\n\r\n  async getStorageInfo(): Promise<{\r\n    projects: number;\r\n    isOPFSSupported: boolean;\r\n    isIndexedDBSupported: boolean;\r\n  }> {\r\n    const projectIds = await this.projectsAdapter.list();\r\n\r\n    return {\r\n      projects: projectIds.length,\r\n      isOPFSSupported: this.isOPFSSupported(),\r\n      isIndexedDBSupported: this.isIndexedDBSupported(),\r\n    };\r\n  }\r\n\r\n  async getProjectStorageInfo(projectId: string): Promise<{\r\n    mediaItems: number;\r\n    hasTimeline: boolean;\r\n  }> {\r\n    const { mediaMetadataAdapter } = this.getProjectMediaAdapters(projectId);\r\n    const timelineAdapter = this.getProjectTimelineAdapter(projectId);\r\n\r\n    const [mediaIds, timelineData] = await Promise.all([\r\n      mediaMetadataAdapter.list(),\r\n      timelineAdapter.get(\"timeline\"),\r\n    ]);\r\n\r\n    return {\r\n      mediaItems: mediaIds.length,\r\n      hasTimeline: !!timelineData,\r\n    };\r\n  }\r\n\r\n  async loadSavedSounds(): Promise<SavedSoundsData> {\r\n    try {\r\n      const savedSoundsData = await this.savedSoundsAdapter.get(\"user-sounds\");\r\n      return (\r\n        savedSoundsData || {\r\n          sounds: [],\r\n          lastModified: new Date().toISOString(),\r\n        }\r\n      );\r\n    } catch (error) {\r\n      console.error(\"Failed to load saved sounds:\", error);\r\n      return { sounds: [], lastModified: new Date().toISOString() };\r\n    }\r\n  }\r\n\r\n  async saveSoundEffect(soundEffect: SoundEffect): Promise<void> {\r\n    try {\r\n      const currentData = await this.loadSavedSounds();\r\n\r\n      // Check if sound is already saved\r\n      if (currentData.sounds.some((sound) => sound.id === soundEffect.id)) {\r\n        return; // Already saved\r\n      }\r\n\r\n      const savedSound: SavedSound = {\r\n        id: soundEffect.id,\r\n        name: soundEffect.name,\r\n        username: soundEffect.username,\r\n        previewUrl: soundEffect.previewUrl,\r\n        downloadUrl: soundEffect.downloadUrl,\r\n        duration: soundEffect.duration,\r\n        tags: soundEffect.tags,\r\n        license: soundEffect.license,\r\n        savedAt: new Date().toISOString(),\r\n      };\r\n\r\n      const updatedData: SavedSoundsData = {\r\n        sounds: [...currentData.sounds, savedSound],\r\n        lastModified: new Date().toISOString(),\r\n      };\r\n\r\n      await this.savedSoundsAdapter.set(\"user-sounds\", updatedData);\r\n    } catch (error) {\r\n      console.error(\"Failed to save sound effect:\", error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async removeSavedSound(soundId: number): Promise<void> {\r\n    try {\r\n      const currentData = await this.loadSavedSounds();\r\n\r\n      const updatedData: SavedSoundsData = {\r\n        sounds: currentData.sounds.filter((sound) => sound.id !== soundId),\r\n        lastModified: new Date().toISOString(),\r\n      };\r\n\r\n      await this.savedSoundsAdapter.set(\"user-sounds\", updatedData);\r\n    } catch (error) {\r\n      console.error(\"Failed to remove saved sound:\", error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async isSoundSaved(soundId: number): Promise<boolean> {\r\n    try {\r\n      const currentData = await this.loadSavedSounds();\r\n      return currentData.sounds.some((sound) => sound.id === soundId);\r\n    } catch (error) {\r\n      console.error(\"Failed to check if sound is saved:\", error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async clearSavedSounds(): Promise<void> {\r\n    try {\r\n      await this.savedSoundsAdapter.remove(\"user-sounds\");\r\n    } catch (error) {\r\n      console.error(\"Failed to clear saved sounds:\", error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Check browser support\r\n  isOPFSSupported(): boolean {\r\n    return OPFSAdapter.isSupported();\r\n  }\r\n\r\n  isIndexedDBSupported(): boolean {\r\n    return \"indexedDB\" in window;\r\n  }\r\n\r\n  isFullySupported(): boolean {\r\n    return this.isIndexedDBSupported() && this.isOPFSSupported();\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const storageService = new StorageService();\r\nexport { StorageService };\r\n","import { create } from \"zustand\";\r\nimport { CanvasSize, CanvasPreset } from \"@/types/editor\";\r\n\r\ntype CanvasMode = \"preset\" | \"original\" | \"custom\";\r\n\r\ninterface EditorState {\r\n  // Loading states\r\n  isInitializing: boolean;\r\n  isPanelsReady: boolean;\r\n\r\n  // Canvas/Project settings\r\n  canvasSize: CanvasSize;\r\n  canvasMode: CanvasMode;\r\n  canvasPresets: CanvasPreset[];\r\n\r\n  // Actions\r\n  setInitializing: (loading: boolean) => void;\r\n  setPanelsReady: (ready: boolean) => void;\r\n  initializeApp: () => Promise<void>;\r\n  setCanvasSize: (size: CanvasSize) => void;\r\n  setCanvasSizeToOriginal: (aspectRatio: number) => void;\r\n  setCanvasSizeFromAspectRatio: (aspectRatio: number) => void;\r\n}\r\n\r\nconst DEFAULT_CANVAS_PRESETS: CanvasPreset[] = [\r\n  { name: \"16:9\", width: 1920, height: 1080 },\r\n  { name: \"9:16\", width: 1080, height: 1920 },\r\n  { name: \"1:1\", width: 1080, height: 1080 },\r\n  { name: \"4:3\", width: 1440, height: 1080 },\r\n];\r\n\r\n// Helper function to find the best matching canvas preset for an aspect ratio\r\nconst findBestCanvasPreset = (aspectRatio: number): CanvasSize => {\r\n  // Calculate aspect ratio for each preset and find the closest match\r\n  let bestMatch = DEFAULT_CANVAS_PRESETS[0]; // Default to 16:9 HD\r\n  let smallestDifference = Math.abs(\r\n    aspectRatio - bestMatch.width / bestMatch.height\r\n  );\r\n\r\n  for (const preset of DEFAULT_CANVAS_PRESETS) {\r\n    const presetAspectRatio = preset.width / preset.height;\r\n    const difference = Math.abs(aspectRatio - presetAspectRatio);\r\n\r\n    if (difference < smallestDifference) {\r\n      smallestDifference = difference;\r\n      bestMatch = preset;\r\n    }\r\n  }\r\n\r\n  // If the difference is still significant (> 0.1), create a custom size\r\n  // based on the media aspect ratio with a reasonable resolution\r\n  const bestAspectRatio = bestMatch.width / bestMatch.height;\r\n  if (Math.abs(aspectRatio - bestAspectRatio) > 0.1) {\r\n    // Create custom dimensions based on the aspect ratio\r\n    if (aspectRatio > 1) {\r\n      // Landscape - use 1920 width\r\n      return { width: 1920, height: Math.round(1920 / aspectRatio) };\r\n    }\r\n    // Portrait or square - use 1080 height\r\n    return { width: Math.round(1080 * aspectRatio), height: 1080 };\r\n  }\r\n\r\n  return { width: bestMatch.width, height: bestMatch.height };\r\n};\r\n\r\nexport const useEditorStore = create<EditorState>((set, get) => ({\r\n  // Initial states\r\n  isInitializing: true,\r\n  isPanelsReady: false,\r\n  canvasSize: { width: 1920, height: 1080 }, // Default 16:9 HD\r\n  canvasMode: \"preset\" as CanvasMode,\r\n  canvasPresets: DEFAULT_CANVAS_PRESETS,\r\n\r\n  // Actions\r\n  setInitializing: (loading) => {\r\n    set({ isInitializing: loading });\r\n  },\r\n\r\n  setPanelsReady: (ready) => {\r\n    set({ isPanelsReady: ready });\r\n  },\r\n\r\n  initializeApp: async () => {\r\n    console.log(\"Initializing video editor...\");\r\n    set({ isInitializing: true, isPanelsReady: false });\r\n\r\n    set({ isPanelsReady: true, isInitializing: false });\r\n    console.log(\"Video editor ready\");\r\n  },\r\n\r\n  setCanvasSize: (size) => {\r\n    set({ canvasSize: size, canvasMode: \"preset\" });\r\n  },\r\n\r\n  setCanvasSizeToOriginal: (aspectRatio) => {\r\n    const newCanvasSize = findBestCanvasPreset(aspectRatio);\r\n    set({ canvasSize: newCanvasSize, canvasMode: \"original\" });\r\n  },\r\n\r\n  setCanvasSizeFromAspectRatio: (aspectRatio) => {\r\n    const newCanvasSize = findBestCanvasPreset(aspectRatio);\r\n    set({ canvasSize: newCanvasSize, canvasMode: \"custom\" });\r\n  },\r\n}));\r\n","import { create } from \"zustand\";\r\nimport { storageService } from \"@/lib/storage/storage-service\";\r\nimport { useTimelineStore } from \"./timeline-store\";\r\nimport { generateUUID } from \"@/lib/utils\";\r\n\r\nexport type MediaType = \"image\" | \"video\" | \"audio\";\r\n\r\nexport interface MediaItem {\r\n  id: string;\r\n  name: string;\r\n  type: MediaType;\r\n  file: File;\r\n  url?: string; // Object URL for preview\r\n  thumbnailUrl?: string; // For video thumbnails\r\n  duration?: number; // For video/audio duration\r\n  width?: number; // For video/image width\r\n  height?: number; // For video/image height\r\n  fps?: number; // For video frame rate\r\n  // Text-specific properties\r\n  content?: string; // Text content\r\n  fontSize?: number; // Font size\r\n  fontFamily?: string; // Font family\r\n  color?: string; // Text color\r\n  backgroundColor?: string; // Background color\r\n  textAlign?: \"left\" | \"center\" | \"right\"; // Text alignment\r\n}\r\n\r\ninterface MediaStore {\r\n  mediaItems: MediaItem[];\r\n  isLoading: boolean;\r\n\r\n  // Actions - now require projectId\r\n  addMediaItem: (\r\n    projectId: string,\r\n    item: Omit<MediaItem, \"id\">\r\n  ) => Promise<void>;\r\n  removeMediaItem: (projectId: string, id: string) => Promise<void>;\r\n  loadProjectMedia: (projectId: string) => Promise<void>;\r\n  clearProjectMedia: (projectId: string) => Promise<void>;\r\n  clearAllMedia: () => void; // Clear local state only\r\n}\r\n\r\n// Helper function to determine file type\r\nexport const getFileType = (file: File): MediaType | null => {\r\n  const { type } = file;\r\n\r\n  if (type.startsWith(\"image/\")) {\r\n    return \"image\";\r\n  }\r\n  if (type.startsWith(\"video/\")) {\r\n    return \"video\";\r\n  }\r\n  if (type.startsWith(\"audio/\")) {\r\n    return \"audio\";\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\n// Helper function to get image dimensions\r\nexport const getImageDimensions = (\r\n  file: File\r\n): Promise<{ width: number; height: number }> => {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new window.Image();\r\n\r\n    img.addEventListener(\"load\", () => {\r\n      const width = img.naturalWidth;\r\n      const height = img.naturalHeight;\r\n      resolve({ width, height });\r\n      img.remove();\r\n    });\r\n\r\n    img.addEventListener(\"error\", () => {\r\n      reject(new Error(\"Could not load image\"));\r\n      img.remove();\r\n    });\r\n\r\n    img.src = URL.createObjectURL(file);\r\n  });\r\n};\r\n\r\n// Helper function to generate video thumbnail and get dimensions\r\nexport const generateVideoThumbnail = (\r\n  file: File\r\n): Promise<{ thumbnailUrl: string; width: number; height: number }> => {\r\n  return new Promise((resolve, reject) => {\r\n    const video = document.createElement(\"video\") as HTMLVideoElement;\r\n    const canvas = document.createElement(\"canvas\") as HTMLCanvasElement;\r\n    const ctx = canvas.getContext(\"2d\");\r\n\r\n    if (!ctx) {\r\n      reject(new Error(\"Could not get canvas context\"));\r\n      return;\r\n    }\r\n\r\n    video.addEventListener(\"loadedmetadata\", () => {\r\n      canvas.width = video.videoWidth;\r\n      canvas.height = video.videoHeight;\r\n\r\n      // Seek to 1 second or 10% of duration, whichever is smaller\r\n      video.currentTime = Math.min(1, video.duration * 0.1);\r\n    });\r\n\r\n    video.addEventListener(\"seeked\", () => {\r\n      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n      const thumbnailUrl = canvas.toDataURL(\"image/jpeg\", 0.8);\r\n      const width = video.videoWidth;\r\n      const height = video.videoHeight;\r\n\r\n      resolve({ thumbnailUrl, width, height });\r\n\r\n      // Cleanup\r\n      video.remove();\r\n      canvas.remove();\r\n    });\r\n\r\n    video.addEventListener(\"error\", () => {\r\n      reject(new Error(\"Could not load video\"));\r\n      video.remove();\r\n      canvas.remove();\r\n    });\r\n\r\n    video.src = URL.createObjectURL(file);\r\n    video.load();\r\n  });\r\n};\r\n\r\n// Helper function to get media duration\r\nexport const getMediaDuration = (file: File): Promise<number> => {\r\n  return new Promise((resolve, reject) => {\r\n    const element = document.createElement(\r\n      file.type.startsWith(\"video/\") ? \"video\" : \"audio\"\r\n    ) as HTMLVideoElement;\r\n\r\n    element.addEventListener(\"loadedmetadata\", () => {\r\n      resolve(element.duration);\r\n      element.remove();\r\n    });\r\n\r\n    element.addEventListener(\"error\", () => {\r\n      reject(new Error(\"Could not load media\"));\r\n      element.remove();\r\n    });\r\n\r\n    element.src = URL.createObjectURL(file);\r\n    element.load();\r\n  });\r\n};\r\n\r\n// Helper to get aspect ratio from MediaItem\r\nexport const getMediaAspectRatio = (item: MediaItem): number => {\r\n  if (item.width && item.height) {\r\n    return item.width / item.height;\r\n  }\r\n  return 16 / 9; // Default aspect ratio\r\n};\r\n\r\nexport const useMediaStore = create<MediaStore>((set, get) => ({\r\n  mediaItems: [],\r\n  isLoading: false,\r\n\r\n  addMediaItem: async (projectId, item) => {\r\n    const newItem: MediaItem = {\r\n      ...item,\r\n      id: generateUUID(),\r\n    };\r\n\r\n    // Add to local state immediately for UI responsiveness\r\n    set((state) => ({\r\n      mediaItems: [...state.mediaItems, newItem],\r\n    }));\r\n\r\n    // Save to persistent storage in background\r\n    try {\r\n      await storageService.saveMediaItem(projectId, newItem);\r\n    } catch (error) {\r\n      console.error(\"Failed to save media item:\", error);\r\n      // Remove from local state if save failed\r\n      set((state) => ({\r\n        mediaItems: state.mediaItems.filter((media) => media.id !== newItem.id),\r\n      }));\r\n    }\r\n  },\r\n\r\n  removeMediaItem: async (projectId: string, id: string) => {\r\n    const state = get();\r\n    const item = state.mediaItems.find((media) => media.id === id);\r\n\r\n    // Cleanup object URLs to prevent memory leaks\r\n    if (item?.url) {\r\n      URL.revokeObjectURL(item.url);\r\n      if (item.thumbnailUrl) {\r\n        URL.revokeObjectURL(item.thumbnailUrl);\r\n      }\r\n    }\r\n\r\n    // 1) Remove from local state immediately\r\n    set((state) => ({\r\n      mediaItems: state.mediaItems.filter((media) => media.id !== id),\r\n    }));\r\n\r\n    // 2) Cascade into the timeline: remove any elements using this media ID\r\n    const timeline = useTimelineStore.getState();\r\n    const {\r\n      tracks,\r\n      removeElementFromTrack,\r\n      removeElementFromTrackWithRipple,\r\n      rippleEditingEnabled,\r\n      pushHistory,\r\n    } = timeline;\r\n\r\n    // Find all elements that reference this media\r\n    const elementsToRemove: Array<{ trackId: string; elementId: string }> = [];\r\n    for (const track of tracks) {\r\n      for (const el of track.elements) {\r\n        if (el.type === \"media\" && el.mediaId === id) {\r\n          elementsToRemove.push({ trackId: track.id, elementId: el.id });\r\n        }\r\n      }\r\n    }\r\n\r\n    // If there are elements to remove, push history once before batch removal\r\n    if (elementsToRemove.length > 0) {\r\n      pushHistory();\r\n\r\n      // Remove all elements without pushing additional history entries\r\n      for (const { trackId, elementId } of elementsToRemove) {\r\n        if (rippleEditingEnabled) {\r\n          removeElementFromTrackWithRipple(trackId, elementId, false);\r\n        } else {\r\n          removeElementFromTrack(trackId, elementId, false);\r\n        }\r\n      }\r\n    }\r\n\r\n    // 3) Remove from persistent storage\r\n    try {\r\n      await storageService.deleteMediaItem(projectId, id);\r\n    } catch (error) {\r\n      console.error(\"Failed to delete media item:\", error);\r\n    }\r\n  },\r\n\r\n  loadProjectMedia: async (projectId) => {\r\n    set({ isLoading: true });\r\n\r\n    try {\r\n      const mediaItems = await storageService.loadAllMediaItems(projectId);\r\n\r\n      // Regenerate thumbnails for video items\r\n      const updatedMediaItems = await Promise.all(\r\n        mediaItems.map(async (item) => {\r\n          if (item.type === \"video\" && item.file) {\r\n            try {\r\n              const { thumbnailUrl, width, height } =\r\n                await generateVideoThumbnail(item.file);\r\n              return {\r\n                ...item,\r\n                thumbnailUrl,\r\n                width: width || item.width,\r\n                height: height || item.height,\r\n              };\r\n            } catch (error) {\r\n              console.error(\r\n                `Failed to regenerate thumbnail for video ${item.id}:`,\r\n                error\r\n              );\r\n              return item;\r\n            }\r\n          }\r\n          return item;\r\n        })\r\n      );\r\n\r\n      set({ mediaItems: updatedMediaItems });\r\n    } catch (error) {\r\n      console.error(\"Failed to load media items:\", error);\r\n    } finally {\r\n      set({ isLoading: false });\r\n    }\r\n  },\r\n\r\n  clearProjectMedia: async (projectId) => {\r\n    const state = get();\r\n\r\n    // Cleanup all object URLs\r\n    state.mediaItems.forEach((item) => {\r\n      if (item.url) {\r\n        URL.revokeObjectURL(item.url);\r\n      }\r\n      if (item.thumbnailUrl) {\r\n        URL.revokeObjectURL(item.thumbnailUrl);\r\n      }\r\n    });\r\n\r\n    // Clear local state\r\n    set({ mediaItems: [] });\r\n\r\n    // Clear persistent storage\r\n    try {\r\n      const mediaIds = state.mediaItems.map((item) => item.id);\r\n      await Promise.all(\r\n        mediaIds.map((id) => storageService.deleteMediaItem(projectId, id))\r\n      );\r\n    } catch (error) {\r\n      console.error(\"Failed to clear media items from storage:\", error);\r\n    }\r\n  },\r\n\r\n  clearAllMedia: () => {\r\n    const state = get();\r\n\r\n    // Cleanup all object URLs\r\n    state.mediaItems.forEach((item) => {\r\n      if (item.url) {\r\n        URL.revokeObjectURL(item.url);\r\n      }\r\n      if (item.thumbnailUrl) {\r\n        URL.revokeObjectURL(item.thumbnailUrl);\r\n      }\r\n    });\r\n\r\n    // Clear local state\r\n    set({ mediaItems: [] });\r\n  },\r\n}));\r\n","import { TProject } from \"@/types/project\";\r\nimport { create } from \"zustand\";\r\nimport { storageService } from \"@/lib/storage/storage-service\";\r\nimport { toast } from \"sonner\";\r\nimport { useMediaStore } from \"./media-store\";\r\nimport { useTimelineStore } from \"./timeline-store\";\r\nimport { generateUUID } from \"@/lib/utils\";\r\n\r\ninterface ProjectStore {\r\n  activeProject: TProject | null;\r\n  savedProjects: TProject[];\r\n  isLoading: boolean;\r\n  isInitialized: boolean;\r\n  invalidProjectIds?: Set<string>;\r\n\r\n  // Actions\r\n  createNewProject: (name: string) => Promise<string>;\r\n  loadProject: (id: string) => Promise<void>;\r\n  saveCurrentProject: () => Promise<void>;\r\n  loadAllProjects: () => Promise<void>;\r\n  deleteProject: (id: string) => Promise<void>;\r\n  closeProject: () => void;\r\n  renameProject: (projectId: string, name: string) => Promise<void>;\r\n  duplicateProject: (projectId: string) => Promise<string>;\r\n  updateProjectBackground: (backgroundColor: string) => Promise<void>;\r\n  updateBackgroundType: (\r\n    type: \"color\" | \"blur\",\r\n    options?: { backgroundColor?: string; blurIntensity?: number }\r\n  ) => Promise<void>;\r\n  updateProjectFps: (fps: number) => Promise<void>;\r\n\r\n  // Bookmark methods\r\n  toggleBookmark: (time: number) => Promise<void>;\r\n  isBookmarked: (time: number) => boolean;\r\n  removeBookmark: (time: number) => Promise<void>;\r\n\r\n  getFilteredAndSortedProjects: (\r\n    searchQuery: string,\r\n    sortOption: string\r\n  ) => TProject[];\r\n\r\n  // Global invalid project ID tracking\r\n  isInvalidProjectId: (id: string) => boolean;\r\n  markProjectIdAsInvalid: (id: string) => void;\r\n  clearInvalidProjectIds: () => void;\r\n}\r\n\r\nexport const useProjectStore = create<ProjectStore>((set, get) => ({\r\n  activeProject: null,\r\n  savedProjects: [],\r\n  isLoading: true,\r\n  isInitialized: false,\r\n  invalidProjectIds: new Set<string>(),\r\n\r\n  // Implementation of bookmark methods\r\n  toggleBookmark: async (time: number) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    // Round time to the nearest frame\r\n    const fps = activeProject.fps || 30;\r\n    const frameTime = Math.round(time * fps) / fps;\r\n\r\n    const bookmarks = activeProject.bookmarks || [];\r\n    let updatedBookmarks: number[];\r\n\r\n    // Check if already bookmarked\r\n    const bookmarkIndex = bookmarks.findIndex(\r\n      (bookmark) => Math.abs(bookmark - frameTime) < 0.001\r\n    );\r\n\r\n    if (bookmarkIndex !== -1) {\r\n      // Remove bookmark\r\n      updatedBookmarks = bookmarks.filter((_, i) => i !== bookmarkIndex);\r\n    } else {\r\n      // Add bookmark\r\n      updatedBookmarks = [...bookmarks, frameTime].sort((a, b) => a - b);\r\n    }\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      bookmarks: updatedBookmarks,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update project bookmarks:\", error);\r\n      toast.error(\"Failed to update bookmarks\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  isBookmarked: (time: number) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject || !activeProject.bookmarks) return false;\r\n\r\n    // Round time to the nearest frame\r\n    const fps = activeProject.fps || 30;\r\n    const frameTime = Math.round(time * fps) / fps;\r\n\r\n    return activeProject.bookmarks.some(\r\n      (bookmark) => Math.abs(bookmark - frameTime) < 0.001\r\n    );\r\n  },\r\n\r\n  removeBookmark: async (time: number) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject || !activeProject.bookmarks) return;\r\n\r\n    // Round time to the nearest frame\r\n    const fps = activeProject.fps || 30;\r\n    const frameTime = Math.round(time * fps) / fps;\r\n\r\n    const updatedBookmarks = activeProject.bookmarks.filter(\r\n      (bookmark) => Math.abs(bookmark - frameTime) >= 0.001\r\n    );\r\n\r\n    if (updatedBookmarks.length === activeProject.bookmarks.length) {\r\n      // No bookmark found to remove\r\n      return;\r\n    }\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      bookmarks: updatedBookmarks,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update project bookmarks:\", error);\r\n      toast.error(\"Failed to remove bookmark\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  createNewProject: async (name: string) => {\r\n    const newProject: TProject = {\r\n      id: generateUUID(),\r\n      name,\r\n      thumbnail: \"\",\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n      backgroundColor: \"#000000\",\r\n      backgroundType: \"color\",\r\n      blurIntensity: 8,\r\n      bookmarks: [],\r\n      fps: 30,\r\n    };\r\n\r\n    set({ activeProject: newProject });\r\n\r\n    try {\r\n      await storageService.saveProject(newProject);\r\n      // Reload all projects to update the list\r\n      await get().loadAllProjects();\r\n      return newProject.id;\r\n    } catch (error) {\r\n      toast.error(\"Failed to save new project\");\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  loadProject: async (id: string) => {\r\n    if (!get().isInitialized) {\r\n      set({ isLoading: true });\r\n    }\r\n\r\n    // Clear media and timeline immediately to prevent flickering when switching projects\r\n    const mediaStore = useMediaStore.getState();\r\n    const timelineStore = useTimelineStore.getState();\r\n    mediaStore.clearAllMedia();\r\n    timelineStore.clearTimeline();\r\n\r\n    try {\r\n      const project = await storageService.loadProject(id);\r\n      if (project) {\r\n        set({ activeProject: project });\r\n\r\n        // Load project-specific data in parallel\r\n        await Promise.all([\r\n          mediaStore.loadProjectMedia(id),\r\n          timelineStore.loadProjectTimeline(id),\r\n        ]);\r\n      } else {\r\n        throw new Error(`Project with id ${id} not found`);\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Failed to load project:\", error);\r\n      throw error; // Re-throw so the editor page can handle it\r\n    } finally {\r\n      set({ isLoading: false });\r\n    }\r\n  },\r\n\r\n  saveCurrentProject: async () => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    try {\r\n      // Save project metadata and timeline data in parallel\r\n      const timelineStore = useTimelineStore.getState();\r\n      await Promise.all([\r\n        storageService.saveProject(activeProject),\r\n        timelineStore.saveProjectTimeline(activeProject.id),\r\n      ]);\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to save project:\", error);\r\n    }\r\n  },\r\n\r\n  loadAllProjects: async () => {\r\n    if (!get().isInitialized) {\r\n      set({ isLoading: true });\r\n    }\r\n\r\n    try {\r\n      const projects = await storageService.loadAllProjects();\r\n      set({ savedProjects: projects });\r\n    } catch (error) {\r\n      console.error(\"Failed to load projects:\", error);\r\n    } finally {\r\n      set({ isLoading: false, isInitialized: true });\r\n    }\r\n  },\r\n\r\n  deleteProject: async (id: string) => {\r\n    try {\r\n      // Delete project data in parallel\r\n      await Promise.all([\r\n        storageService.deleteProjectMedia(id),\r\n        storageService.deleteProjectTimeline(id),\r\n        storageService.deleteProject(id),\r\n      ]);\r\n      await get().loadAllProjects(); // Refresh the list\r\n\r\n      // If we deleted the active project, close it and clear data\r\n      const { activeProject } = get();\r\n      if (activeProject?.id === id) {\r\n        set({ activeProject: null });\r\n        const mediaStore = useMediaStore.getState();\r\n        const timelineStore = useTimelineStore.getState();\r\n        mediaStore.clearAllMedia();\r\n        timelineStore.clearTimeline();\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Failed to delete project:\", error);\r\n    }\r\n  },\r\n\r\n  closeProject: () => {\r\n    set({ activeProject: null });\r\n\r\n    // Clear data from stores when closing project\r\n    const mediaStore = useMediaStore.getState();\r\n    const timelineStore = useTimelineStore.getState();\r\n    mediaStore.clearAllMedia();\r\n    timelineStore.clearTimeline();\r\n  },\r\n\r\n  renameProject: async (id: string, name: string) => {\r\n    const { savedProjects } = get();\r\n\r\n    // Find the project to rename\r\n    const projectToRename = savedProjects.find((p) => p.id === id);\r\n    if (!projectToRename) {\r\n      toast.error(\"Project not found\", {\r\n        description: \"Please try again\",\r\n      });\r\n      return;\r\n    }\r\n\r\n    const updatedProject = {\r\n      ...projectToRename,\r\n      name,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      // Save to storage\r\n      await storageService.saveProject(updatedProject);\r\n\r\n      await get().loadAllProjects();\r\n\r\n      // Update activeProject if it's the same project\r\n      const { activeProject } = get();\r\n      if (activeProject?.id === id) {\r\n        set({ activeProject: updatedProject });\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Failed to rename project:\", error);\r\n      toast.error(\"Failed to rename project\", {\r\n        description:\r\n          error instanceof Error ? error.message : \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  duplicateProject: async (projectId: string) => {\r\n    try {\r\n      const project = await storageService.loadProject(projectId);\r\n      if (!project) {\r\n        toast.error(\"Project not found\", {\r\n          description: \"Please try again\",\r\n        });\r\n        throw new Error(\"Project not found\");\r\n      }\r\n\r\n      const { savedProjects } = get();\r\n\r\n      // Extract the base name (remove any existing numbering)\r\n      const numberMatch = project.name.match(/^\\((\\d+)\\)\\s+(.+)$/);\r\n      const baseName = numberMatch ? numberMatch[2] : project.name;\r\n      const existingNumbers: number[] = [];\r\n\r\n      // Check for pattern \"(number) baseName\" in existing projects\r\n      savedProjects.forEach((p) => {\r\n        const match = p.name.match(/^\\((\\d+)\\)\\s+(.+)$/);\r\n        if (match && match[2] === baseName) {\r\n          existingNumbers.push(parseInt(match[1], 10));\r\n        }\r\n      });\r\n\r\n      const nextNumber =\r\n        existingNumbers.length > 0 ? Math.max(...existingNumbers) + 1 : 1;\r\n\r\n      const newProject: TProject = {\r\n        ...project, // Copy all properties from the original project\r\n        id: generateUUID(),\r\n        name: `(${nextNumber}) ${baseName}`,\r\n        createdAt: new Date(),\r\n        updatedAt: new Date(),\r\n      };\r\n\r\n      await storageService.saveProject(newProject);\r\n      await get().loadAllProjects();\r\n      return newProject.id;\r\n    } catch (error) {\r\n      console.error(\"Failed to duplicate project:\", error);\r\n      toast.error(\"Failed to duplicate project\", {\r\n        description:\r\n          error instanceof Error ? error.message : \"Please try again\",\r\n      });\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  updateProjectBackground: async (backgroundColor: string) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      backgroundColor,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update project background:\", error);\r\n      toast.error(\"Failed to update background\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  updateBackgroundType: async (\r\n    type: \"color\" | \"blur\",\r\n    options?: { backgroundColor?: string; blurIntensity?: number }\r\n  ) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      backgroundType: type,\r\n      ...(options?.backgroundColor && {\r\n        backgroundColor: options.backgroundColor,\r\n      }),\r\n      ...(options?.blurIntensity && { blurIntensity: options.blurIntensity }),\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update background type:\", error);\r\n      toast.error(\"Failed to update background\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  updateProjectFps: async (fps: number) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      fps,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update project FPS:\", error);\r\n      toast.error(\"Failed to update project FPS\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  getFilteredAndSortedProjects: (searchQuery: string, sortOption: string) => {\r\n    const { savedProjects } = get();\r\n\r\n    // Filter projects by search query\r\n    const filteredProjects = savedProjects.filter((project) =>\r\n      project.name.toLowerCase().includes(searchQuery.toLowerCase())\r\n    );\r\n\r\n    // Sort filtered projects\r\n    const sortedProjects = [...filteredProjects].sort((a, b) => {\r\n      const [key, order] = sortOption.split(\"-\");\r\n\r\n      if (key !== \"createdAt\" && key !== \"name\") {\r\n        console.warn(`Invalid sort key: ${key}`);\r\n        return 0;\r\n      }\r\n\r\n      const aValue = a[key];\r\n      const bValue = b[key];\r\n\r\n      if (aValue === undefined || bValue === undefined) return 0;\r\n\r\n      if (order === \"asc\") {\r\n        if (aValue < bValue) return -1;\r\n        if (aValue > bValue) return 1;\r\n        return 0;\r\n      }\r\n      if (aValue > bValue) return -1;\r\n      if (aValue < bValue) return 1;\r\n      return 0;\r\n    });\r\n\r\n    return sortedProjects;\r\n  },\r\n\r\n  // Global invalid project ID tracking implementation\r\n  isInvalidProjectId: (id: string) => {\r\n    const invalidIds = get().invalidProjectIds || new Set();\r\n    return invalidIds.has(id);\r\n  },\r\n\r\n  markProjectIdAsInvalid: (id: string) => {\r\n    set((state) => ({\r\n      invalidProjectIds: new Set([\r\n        ...(state.invalidProjectIds || new Set()),\r\n        id,\r\n      ]),\r\n    }));\r\n  },\r\n\r\n  clearInvalidProjectIds: () => {\r\n    set({ invalidProjectIds: new Set() });\r\n  },\r\n}));\r\n","import type { TrackType } from \"@/types/timeline\";\r\n\r\n// Track color definitions\r\nexport const TRACK_COLORS: Record<\r\n  TrackType,\r\n  { solid: string; background: string; border: string }\r\n> = {\r\n  media: {\r\n    solid: \"bg-blue-500\",\r\n    background: \"\",\r\n    border: \"\",\r\n  },\r\n  text: {\r\n    solid: \"bg-[#5DBAA0]\",\r\n    background: \"bg-[#5DBAA0]\",\r\n    border: \"\",\r\n  },\r\n  audio: {\r\n    solid: \"bg-green-500\",\r\n    background: \"bg-[#915DBE]\",\r\n    border: \"\",\r\n  },\r\n} as const;\r\n\r\n// Utility functions\r\nexport function getTrackColors(type: TrackType) {\r\n  return TRACK_COLORS[type];\r\n}\r\n\r\nexport function getTrackElementClasses(type: TrackType) {\r\n  const colors = getTrackColors(type);\r\n  return `${colors.background} ${colors.border}`;\r\n}\r\n\r\n// Track height definitions\r\nexport const TRACK_HEIGHTS: Record<TrackType, number> = {\r\n  media: 60,\r\n  text: 25,\r\n  audio: 50,\r\n} as const;\r\n\r\n// Utility function for track heights\r\nexport function getTrackHeight(type: TrackType): number {\r\n  return TRACK_HEIGHTS[type];\r\n}\r\n\r\n// Calculate cumulative height up to (but not including) a track index\r\nexport function getCumulativeHeightBefore(\r\n  tracks: Array<{ type: TrackType }>,\r\n  trackIndex: number\r\n): number {\r\n  const GAP = 4; // 4px gap between tracks (equivalent to Tailwind's gap-1)\r\n  return tracks\r\n    .slice(0, trackIndex)\r\n    .reduce((sum, track) => sum + getTrackHeight(track.type) + GAP, 0);\r\n}\r\n\r\n// Calculate total height of all tracks\r\nexport function getTotalTracksHeight(\r\n  tracks: Array<{ type: TrackType }>\r\n): number {\r\n  const GAP = 4; // 4px gap between tracks (equivalent to Tailwind's gap-1)\r\n  const tracksHeight = tracks.reduce(\r\n    (sum, track) => sum + getTrackHeight(track.type),\r\n    0\r\n  );\r\n  const gapsHeight = Math.max(0, tracks.length - 1) * GAP; // n-1 gaps for n tracks\r\n  return tracksHeight + gapsHeight;\r\n}\r\n\r\n// Other timeline constants\r\nexport const TIMELINE_CONSTANTS = {\r\n  ELEMENT_MIN_WIDTH: 80,\r\n  PIXELS_PER_SECOND: 50,\r\n  TRACK_HEIGHT: 60, // Default fallback\r\n  DEFAULT_TEXT_DURATION: 5,\r\n  DEFAULT_IMAGE_DURATION: 5,\r\n  ZOOM_LEVELS: [0.25, 0.5, 1, 1.5, 2, 3, 4],\r\n} as const;\r\n\r\n// FPS presets for project settings\r\nexport const FPS_PRESETS = [\r\n  { value: \"24\", label: \"24 fps\" },\r\n  { value: \"25\", label: \"25 fps\" },\r\n  { value: \"30\", label: \"30 fps\" },\r\n  { value: \"60\", label: \"60 fps\" },\r\n  { value: \"120\", label: \"120 fps\" },\r\n] as const;\r\n\r\n// Frame snapping utilities\r\nexport function timeToFrame(time: number, fps: number): number {\r\n  return Math.round(time * fps);\r\n}\r\n\r\nexport function frameToTime(frame: number, fps: number): number {\r\n  return frame / fps;\r\n}\r\n\r\nexport function snapTimeToFrame(time: number, fps: number): number {\r\n  if (fps <= 0) return time; // Fallback for invalid FPS\r\n  const frame = timeToFrame(time, fps);\r\n  return frameToTime(frame, fps);\r\n}\r\n\r\nexport function getFrameDuration(fps: number): number {\r\n  return 1 / fps;\r\n}\r\n","// Generic utilities\r\n\r\nimport { type ClassValue, clsx } from \"clsx\";\r\nimport { twMerge } from \"tailwind-merge\";\r\n\r\nexport function cn(...inputs: ClassValue[]) {\r\n  return twMerge(clsx(inputs));\r\n}\r\n\r\n/**\r\n * Generates a UUID v4 string\r\n * Uses crypto.randomUUID() if available, otherwise falls back to a custom implementation\r\n */\r\nexport function generateUUID(): string {\r\n  // Use the native crypto.randomUUID if available\r\n  if (\r\n    typeof crypto !== \"undefined\" &&\r\n    typeof crypto.randomUUID === \"function\"\r\n  ) {\r\n    return crypto.randomUUID();\r\n  }\r\n\r\n  // Secure fallback using crypto.getRandomValues\r\n  const bytes = new Uint8Array(16);\r\n  crypto.getRandomValues(bytes);\r\n\r\n  // Set version 4 (UUIDv4)\r\n  bytes[6] = (bytes[6] & 0x0f) | 0x40;\r\n  // Set variant 10xxxxxx\r\n  bytes[8] = (bytes[8] & 0x3f) | 0x80;\r\n\r\n  const hex = [...bytes].map((b) => b.toString(16).padStart(2, \"0\"));\r\n\r\n  return (\r\n    hex.slice(0, 4).join(\"\") +\r\n    \"-\" +\r\n    hex.slice(4, 6).join(\"\") +\r\n    \"-\" +\r\n    hex.slice(6, 8).join(\"\") +\r\n    \"-\" +\r\n    hex.slice(8, 10).join(\"\") +\r\n    \"-\" +\r\n    hex.slice(10, 16).join(\"\")\r\n  );\r\n}\r\n\r\nexport function isDOMElement(el: any): el is HTMLElement {\r\n  return !!el && (el instanceof Element || el instanceof HTMLElement);\r\n}\r\n\r\nexport function isTypableElement(el: HTMLElement): boolean {\r\n  // If content editable, then it is editable\r\n  if (el.isContentEditable) return true;\r\n\r\n  // If element is an input and the input is enabled, then it is typable\r\n  if (el.tagName === \"INPUT\") {\r\n    return !(el as HTMLInputElement).disabled;\r\n  }\r\n  // If element is a textarea and the input is enabled, then it is typable\r\n  if (el.tagName === \"TEXTAREA\") {\r\n    return !(el as HTMLTextAreaElement).disabled;\r\n  }\r\n\r\n  return false;\r\n}\r\nexport function isAppleDevice() {\r\n  return /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\r\n}\r\n\r\nexport function getPlatformSpecialKey() {\r\n  return isAppleDevice() ? \"⌘\" : \"Ctrl\";\r\n}\r\n\r\nexport function getPlatformAlternateKey() {\r\n  return isAppleDevice() ? \"⌥\" : \"Alt\";\r\n}\r\n"],"names":["checkElementOverlaps","elements","sortedElements","sort","a","b","startTime","i","length","current","next","currentEnd","duration","trimStart","trimEnd","resolvedElements","previous","previousEnd","push","originalName","suffix","baseName","replace","useTimelineStore","create","set","get","updateTracks","tracksWithMain","ensureMainTrack","newTracks","sortedTracks","sortTracksByOrder","_tracks","tracks","autoSaveTimeline","activeProject","useProjectStore","getState","storageService","saveTimeline","id","error","updateTracksAndSave","setTimeout","initialTracks","sortedInitialTracks","history","redoStack","selectedElements","rippleEditingEnabled","snappingEnabled","getSortedTracks","pushHistory","JSON","parse","stringify","undo","slice","selectElement","trackId","elementId","multi","exists","state","some","c","filter","deselectElement","clearSelectedElements","setSelectedElements","addTrack","newTrack","generateUUID","name","trackName","type","muted","insertTrackAt","index","splice","removeTrack","removeTrackWithRipple","track","trackToRemove","find","t","occupiedRanges","map","element","endTime","mergedRanges","range","lastRange","Math","max","updatedTracks","updatedElements","newStartTime","gap","hasOverlaps","resolveElementOverlaps","addElementToTrack","elementData","validateElementTrackCompatibility","isValid","mediaId","content","totalElementsInTimeline","reduce","total","newElement","isFirstElement","mediaItem","useMediaStore","mediaItems","item","useEditorStore","setCanvasSizeFromAspectRatio","getMediaAspectRatio","fps","projectStore","updateProjectFps","removeElementFromTrack","removeElementFromTrackWithRipple","e","elementStartTime","elementDuration","elementEndTime","shouldApplyRipple","currentTrack","currentElement","isMain","moveElementToTrack","fromTrackId","toTrackId","fromTrack","toTrack","elementToMove","updateElementTrim","updateElementDuration","updateElementStartTime","clampedStartTime","updateElementStartTimeWithRipple","oldStartTime","oldEndTime","newEndTime","timeDelta","currentElementStart","toggleTrackMute","toggleElementHidden","hidden","updateTextElement","updates","splitElement","splitTime","effectiveStart","effectiveEnd","relativeTime","secondDuration","secondElementId","flatMap","getElementNameWithSuffix","firstDuration","splitAndKeepLeft","durationToRemove","splitAndKeepRight","separateAudio","existingAudioTrack","audioElementId","newAudioTrack","replaceElementMedia","newFile","success","mediaStore","getFileType","getImageDimensions","generateVideoThumbnail","getMediaDuration","fileType","mediaData","file","url","URL","createObjectURL","width","height","thumbnailUrl","Promise","all","Error","message","addMediaItem","newMediaItem","getTotalDuration","trackEndTimes","maxEnd","elementEnd","getProjectThumbnail","projectId","loadTimeline","loadAllMediaItems","firstMediaElement","redo","dragState","isDragging","startMouseX","startElementTime","clickOffsetTime","currentTime","setDragState","startDrag","updateDragTime","endDrag","loadProjectTimeline","defaultTracks","saveProjectTimeline","clearTimeline","toggleSnapping","toggleRippleEditing","checkElementOverlap","excludeElementId","findOrCreateTrack","trackType","existingTrack","addMediaAtTime","TIMELINE_CONSTANTS","DEFAULT_IMAGE_DURATION","targetTrackId","addTextAtTime","DEFAULT_TEXT_DURATION","fontSize","fontFamily","color","backgroundColor","textAlign","fontWeight","fontStyle","textDecoration","x","y","rotation","opacity","undefined","addMediaToNewTrack","addTextToNewTrack","getMainTrack","hasMainTrack","canElementGoOnTrack","elementType","errorMessage","IndexedDBAdapter","getDB","resolve","reject","request","indexedDB","open","dbName","version","onerror","onsuccess","result","onupgradeneeded","db","target","objectStoreNames","contains","storeName","createObjectStore","keyPath","key","store","transaction","objectStore","value","put","remove","delete","list","getAllKeys","clear","OPFSAdapter","getDirectory","opfsRoot","navigator","storage","getDirectoryHandle","directoryName","directory","fileHandle","getFileHandle","getFile","writable","createWritable","write","close","removeEntry","keys","isSupported","StorageService","getProjectMediaAdapters","mediaMetadataAdapter","config","mediaDb","mediaFilesAdapter","getProjectTimelineAdapter","timelineDb","saveProject","project","serializedProject","thumbnail","createdAt","toISOString","updatedAt","backgroundType","blurIntensity","bookmarks","projectsAdapter","loadProject","Date","loadAllProjects","projectIds","projects","getTime","deleteProject","saveMediaItem","metadata","size","lastModified","loadMediaItem","mediaIds","deleteMediaItem","deleteProjectMedia","timelineAdapter","timelineData","deleteProjectTimeline","clearAllData","getStorageInfo","isOPFSSupported","isIndexedDBSupported","getProjectStorageInfo","hasTimeline","loadSavedSounds","savedSoundsAdapter","sounds","saveSoundEffect","soundEffect","currentData","sound","savedSound","username","previewUrl","downloadUrl","tags","license","savedAt","updatedData","removeSavedSound","soundId","isSoundSaved","clearSavedSounds","window","isFullySupported","projectsDb","savedSoundsDb","DEFAULT_CANVAS_PRESETS","findBestCanvasPreset","bestMatch","smallestDifference","abs","aspectRatio","preset","difference","presetAspectRatio","bestAspectRatio","round","isPanelsReady","canvasSize","canvasMode","canvasPresets","setInitializing","loading","isInitializing","setPanelsReady","ready","initializeApp","setCanvasSize","setCanvasSizeToOriginal","newCanvasSize","startsWith","img","Image","addEventListener","naturalWidth","naturalHeight","src","video","document","createElement","canvas","ctx","getContext","videoWidth","videoHeight","min","drawImage","toDataURL","load","isLoading","newItem","media","removeMediaItem","revokeObjectURL","timeline","elementsToRemove","el","loadProjectMedia","updatedMediaItems","clearProjectMedia","forEach","clearAllMedia","savedProjects","isInitialized","invalidProjectIds","Set","toggleBookmark","time","updatedBookmarks","frameTime","bookmarkIndex","findIndex","bookmark","_","updatedProject","toast","description","isBookmarked","removeBookmark","createNewProject","newProject","timelineStore","saveCurrentProject","closeProject","renameProject","projectToRename","p","duplicateProject","numberMatch","match","existingNumbers","nextNumber","updateProjectBackground","updateBackgroundType","options","getFilteredAndSortedProjects","searchQuery","sortOption","sortedProjects","toLowerCase","includes","order","split","aValue","bValue","isInvalidProjectId","invalidIds","has","markProjectIdAsInvalid","clearInvalidProjectIds","TRACK_COLORS","solid","background","border","text","audio","getTrackElementClasses","colors","getTrackColors","TRACK_HEIGHTS","getTrackHeight","getCumulativeHeightBefore","trackIndex","sum","GAP","getTotalTracksHeight","gapsHeight","ELEMENT_MIN_WIDTH","PIXELS_PER_SECOND","TRACK_HEIGHT","ZOOM_LEVELS","label","snapTimeToFrame","frame","cn","inputs","twMerge","clsx","crypto","randomUUID","bytes","Uint8Array","getRandomValues","hex","toString","padStart","join","isDOMElement","Element","HTMLElement","isTypableElement","isContentEditable","tagName","disabled","isAppleDevice","test","platform","getPlatformSpecialKey","getPlatformAlternateKey"],"sourceRoot":"","ignoreList":[]}