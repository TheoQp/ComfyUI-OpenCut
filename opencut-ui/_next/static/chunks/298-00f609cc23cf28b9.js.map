{"version":3,"file":"static/chunks/298-00f609cc23cf28b9.js","mappings":"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","sources":["webpack://_N_E/./src/types/timeline.ts","webpack://_N_E/./src/lib/storage/indexeddb-adapter.ts","webpack://_N_E/./src/lib/storage/opfs-adapter.ts","webpack://_N_E/./src/lib/storage/storage-service.ts","webpack://_N_E/./src/stores/media-store.ts","webpack://_N_E/./src/stores/project-store.ts","webpack://_N_E/./src/constants/timeline-constants.ts","webpack://_N_E/./src/lib/editor-utils.ts","webpack://_N_E/./src/lib/timeline.ts","webpack://_N_E/./src/stores/timeline-store.ts","webpack://_N_E/./src/lib/utils.ts"],"sourcesContent":["import { MediaType } from \"@/stores/media-store\";\r\nimport { generateUUID } from \"@/lib/utils\";\r\n\r\nexport type TrackType = \"media\" | \"text\" | \"audio\";\r\n\r\n// Base element properties\r\ninterface BaseTimelineElement {\r\n  id: string;\r\n  name: string;\r\n  duration: number;\r\n  startTime: number;\r\n  trimStart: number;\r\n  trimEnd: number;\r\n  hidden?: boolean;\r\n}\r\n\r\n// Media element that references MediaStore\r\nexport interface MediaElement extends BaseTimelineElement {\r\n  type: \"media\";\r\n  mediaId: string;\r\n}\r\n\r\n// Text element with embedded text data\r\nexport interface TextElement extends BaseTimelineElement {\r\n  type: \"text\";\r\n  content: string;\r\n  fontSize: number;\r\n  fontFamily: string;\r\n  color: string;\r\n  backgroundColor: string;\r\n  textAlign: \"left\" | \"center\" | \"right\";\r\n  fontWeight: \"normal\" | \"bold\";\r\n  fontStyle: \"normal\" | \"italic\";\r\n  textDecoration: \"none\" | \"underline\" | \"line-through\";\r\n  x: number; // Position relative to canvas center\r\n  y: number; // Position relative to canvas center\r\n  rotation: number; // in degrees\r\n  opacity: number; // 0-1\r\n}\r\n\r\n// Typed timeline elements\r\nexport type TimelineElement = MediaElement | TextElement;\r\n\r\n// Creation types (without id, for addElementToTrack)\r\nexport type CreateMediaElement = Omit<MediaElement, \"id\">;\r\nexport type CreateTextElement = Omit<TextElement, \"id\">;\r\nexport type CreateTimelineElement = CreateMediaElement | CreateTextElement;\r\n\r\nexport interface TimelineElementProps {\r\n  element: TimelineElement;\r\n  track: TimelineTrack;\r\n  zoomLevel: number;\r\n  isSelected: boolean;\r\n  onElementMouseDown: (e: React.MouseEvent, element: TimelineElement) => void;\r\n  onElementClick: (e: React.MouseEvent, element: TimelineElement) => void;\r\n}\r\n\r\nexport interface ResizeState {\r\n  elementId: string;\r\n  side: \"left\" | \"right\";\r\n  startX: number;\r\n  initialTrimStart: number;\r\n  initialTrimEnd: number;\r\n}\r\n\r\n// Drag data types for type-safe drag and drop\r\nexport interface MediaItemDragData {\r\n  id: string;\r\n  type: MediaType;\r\n  name: string;\r\n}\r\n\r\nexport interface TextItemDragData {\r\n  id: string;\r\n  type: \"text\";\r\n  name: string;\r\n  content: string;\r\n}\r\n\r\nexport type DragData = MediaItemDragData | TextItemDragData;\r\n\r\nexport interface TimelineTrack {\r\n  id: string;\r\n  name: string;\r\n  type: TrackType;\r\n  elements: TimelineElement[];\r\n  muted?: boolean;\r\n  isMain?: boolean;\r\n}\r\n\r\nexport function sortTracksByOrder(tracks: TimelineTrack[]): TimelineTrack[] {\r\n  return [...tracks].sort((a, b) => {\r\n    // Text tracks always go to the top\r\n    if (a.type === \"text\" && b.type !== \"text\") return -1;\r\n    if (b.type === \"text\" && a.type !== \"text\") return 1;\r\n\r\n    // Audio tracks always go to bottom\r\n    if (a.type === \"audio\" && b.type !== \"audio\") return 1;\r\n    if (b.type === \"audio\" && a.type !== \"audio\") return -1;\r\n\r\n    // Main track goes above audio but below text tracks\r\n    if (a.isMain && !b.isMain && b.type !== \"audio\" && b.type !== \"text\")\r\n      return 1;\r\n    if (b.isMain && !a.isMain && a.type !== \"audio\" && a.type !== \"text\")\r\n      return -1;\r\n\r\n    // Within same category, maintain creation order\r\n    return 0;\r\n  });\r\n}\r\n\r\nexport function getMainTrack(tracks: TimelineTrack[]): TimelineTrack | null {\r\n  return tracks.find((track) => track.isMain) || null;\r\n}\r\n\r\nexport function ensureMainTrack(tracks: TimelineTrack[]): TimelineTrack[] {\r\n  const hasMainTrack = tracks.some((track) => track.isMain);\r\n\r\n  if (!hasMainTrack) {\r\n    // Create main track if it doesn't exist\r\n    const mainTrack: TimelineTrack = {\r\n      id: generateUUID(),\r\n      name: \"Main Track\",\r\n      type: \"media\",\r\n      elements: [],\r\n      muted: false,\r\n      isMain: true,\r\n    };\r\n    return [mainTrack, ...tracks];\r\n  }\r\n\r\n  return tracks;\r\n}\r\n\r\n// Timeline validation utilities\r\nexport function canElementGoOnTrack(\r\n  elementType: \"text\" | \"media\",\r\n  trackType: TrackType\r\n): boolean {\r\n  if (elementType === \"text\") {\r\n    return trackType === \"text\";\r\n  }\r\n  if (elementType === \"media\") {\r\n    return trackType === \"media\" || trackType === \"audio\";\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function validateElementTrackCompatibility(\r\n  element: { type: \"text\" | \"media\" },\r\n  track: { type: TrackType }\r\n): { isValid: boolean; errorMessage?: string } {\r\n  const isValid = canElementGoOnTrack(element.type, track.type);\r\n\r\n  if (!isValid) {\r\n    const errorMessage =\r\n      element.type === \"text\"\r\n        ? \"Text elements can only be placed on text tracks\"\r\n        : \"Media elements can only be placed on media or audio tracks\";\r\n\r\n    return { isValid: false, errorMessage };\r\n  }\r\n\r\n  return { isValid: true };\r\n}\r\n","import { StorageAdapter } from \"./types\";\r\n\r\nexport class IndexedDBAdapter<T> implements StorageAdapter<T> {\r\n  private dbName: string;\r\n  private storeName: string;\r\n  private version: number;\r\n\r\n  constructor(dbName: string, storeName: string, version = 1) {\r\n    this.dbName = dbName;\r\n    this.storeName = storeName;\r\n    this.version = version;\r\n  }\r\n\r\n  private async getDB(): Promise<IDBDatabase> {\r\n    return new Promise((resolve, reject) => {\r\n      const request = indexedDB.open(this.dbName, this.version);\r\n\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve(request.result);\r\n\r\n      request.onupgradeneeded = (event) => {\r\n        const db = (event.target as IDBOpenDBRequest).result;\r\n        if (!db.objectStoreNames.contains(this.storeName)) {\r\n          db.createObjectStore(this.storeName, { keyPath: \"id\" });\r\n        }\r\n      };\r\n    });\r\n  }\r\n\r\n  async get(key: string): Promise<T | null> {\r\n    const db = await this.getDB();\r\n    const transaction = db.transaction([this.storeName], \"readonly\");\r\n    const store = transaction.objectStore(this.storeName);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = store.get(key);\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve(request.result || null);\r\n    });\r\n  }\r\n\r\n  async set(key: string, value: T): Promise<void> {\r\n    const db = await this.getDB();\r\n    const transaction = db.transaction([this.storeName], \"readwrite\");\r\n    const store = transaction.objectStore(this.storeName);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = store.put({ id: key, ...value });\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve();\r\n    });\r\n  }\r\n\r\n  async remove(key: string): Promise<void> {\r\n    const db = await this.getDB();\r\n    const transaction = db.transaction([this.storeName], \"readwrite\");\r\n    const store = transaction.objectStore(this.storeName);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = store.delete(key);\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve();\r\n    });\r\n  }\r\n\r\n  async list(): Promise<string[]> {\r\n    const db = await this.getDB();\r\n    const transaction = db.transaction([this.storeName], \"readonly\");\r\n    const store = transaction.objectStore(this.storeName);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = store.getAllKeys();\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve(request.result as string[]);\r\n    });\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    const db = await this.getDB();\r\n    const transaction = db.transaction([this.storeName], \"readwrite\");\r\n    const store = transaction.objectStore(this.storeName);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = store.clear();\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve();\r\n    });\r\n  }\r\n}\r\n","import { StorageAdapter } from \"./types\";\r\n\r\nexport class OPFSAdapter implements StorageAdapter<File> {\r\n  private directoryName: string;\r\n\r\n  constructor(directoryName = \"media\") {\r\n    this.directoryName = directoryName;\r\n  }\r\n\r\n  private async getDirectory(): Promise<FileSystemDirectoryHandle> {\r\n    const opfsRoot = await navigator.storage.getDirectory();\r\n    return await opfsRoot.getDirectoryHandle(this.directoryName, {\r\n      create: true,\r\n    });\r\n  }\r\n\r\n  async get(key: string): Promise<File | null> {\r\n    try {\r\n      const directory = await this.getDirectory();\r\n      const fileHandle = await directory.getFileHandle(key);\r\n      return await fileHandle.getFile();\r\n    } catch (error) {\r\n      if ((error as Error).name === \"NotFoundError\") {\r\n        return null;\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async set(key: string, file: File): Promise<void> {\r\n    const directory = await this.getDirectory();\r\n    const fileHandle = await directory.getFileHandle(key, { create: true });\r\n    const writable = await fileHandle.createWritable();\r\n\r\n    await writable.write(file);\r\n    await writable.close();\r\n  }\r\n\r\n  async remove(key: string): Promise<void> {\r\n    try {\r\n      const directory = await this.getDirectory();\r\n      await directory.removeEntry(key);\r\n    } catch (error) {\r\n      if ((error as Error).name !== \"NotFoundError\") {\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n\r\n  async list(): Promise<string[]> {\r\n    const directory = await this.getDirectory();\r\n    const keys: string[] = [];\r\n\r\n    for await (const name of directory.keys()) {\r\n      keys.push(name);\r\n    }\r\n\r\n    return keys;\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    const directory = await this.getDirectory();\r\n\r\n    for await (const name of directory.keys()) {\r\n      await directory.removeEntry(name);\r\n    }\r\n  }\r\n\r\n  // Helper method to check OPFS support\r\n  static isSupported(): boolean {\r\n    return \"storage\" in navigator && \"getDirectory\" in navigator.storage;\r\n  }\r\n}\r\n","import { TProject } from \"@/types/project\";\r\nimport { MediaItem } from \"@/stores/media-store\";\r\nimport { IndexedDBAdapter } from \"./indexeddb-adapter\";\r\nimport { OPFSAdapter } from \"./opfs-adapter\";\r\nimport {\r\n  MediaFileData,\r\n  StorageConfig,\r\n  SerializedProject,\r\n  TimelineData,\r\n} from \"./types\";\r\nimport { TimelineTrack } from \"@/types/timeline\";\r\nimport { SavedSoundsData, SavedSound, SoundEffect } from \"@/types/sounds\";\r\n\r\nclass StorageService {\r\n  private projectsAdapter: IndexedDBAdapter<SerializedProject>;\r\n  private savedSoundsAdapter: IndexedDBAdapter<SavedSoundsData>;\r\n  private config: StorageConfig;\r\n\r\n  constructor() {\r\n    this.config = {\r\n      projectsDb: \"video-editor-projects\",\r\n      mediaDb: \"video-editor-media\",\r\n      timelineDb: \"video-editor-timelines\",\r\n      savedSoundsDb: \"video-editor-saved-sounds\",\r\n      version: 1,\r\n    };\r\n\r\n    this.projectsAdapter = new IndexedDBAdapter<SerializedProject>(\r\n      this.config.projectsDb,\r\n      \"projects\",\r\n      this.config.version\r\n    );\r\n\r\n    this.savedSoundsAdapter = new IndexedDBAdapter<SavedSoundsData>(\r\n      this.config.savedSoundsDb,\r\n      \"saved-sounds\",\r\n      this.config.version\r\n    );\r\n  }\r\n\r\n  // Helper to get project-specific media adapters\r\n  private getProjectMediaAdapters(projectId: string) {\r\n    const mediaMetadataAdapter = new IndexedDBAdapter<MediaFileData>(\r\n      `${this.config.mediaDb}-${projectId}`,\r\n      \"media-metadata\",\r\n      this.config.version\r\n    );\r\n\r\n    const mediaFilesAdapter = new OPFSAdapter(`media-files-${projectId}`);\r\n\r\n    return { mediaMetadataAdapter, mediaFilesAdapter };\r\n  }\r\n\r\n  // Helper to get project-specific timeline adapter\r\n  private getProjectTimelineAdapter(projectId: string) {\r\n    return new IndexedDBAdapter<TimelineData>(\r\n      `${this.config.timelineDb}-${projectId}`,\r\n      \"timeline\",\r\n      this.config.version\r\n    );\r\n  }\r\n\r\n  // Project operations\r\n  async saveProject(project: TProject): Promise<void> {\r\n    // Convert TProject to serializable format\r\n    const serializedProject: SerializedProject = {\r\n      id: project.id,\r\n      name: project.name,\r\n      thumbnail: project.thumbnail,\r\n      createdAt: project.createdAt.toISOString(),\r\n      updatedAt: project.updatedAt.toISOString(),\r\n      backgroundColor: project.backgroundColor,\r\n      backgroundType: project.backgroundType,\r\n      blurIntensity: project.blurIntensity,\r\n      bookmarks: project.bookmarks,\r\n      fps: project.fps,\r\n      canvasSize: project.canvasSize,\r\n      canvasMode: project.canvasMode,\r\n    };\r\n\r\n    await this.projectsAdapter.set(project.id, serializedProject);\r\n  }\r\n\r\n  async loadProject(id: string): Promise<TProject | null> {\r\n    const serializedProject = await this.projectsAdapter.get(id);\r\n\r\n    if (!serializedProject) return null;\r\n\r\n    // Convert back to TProject format\r\n    return {\r\n      id: serializedProject.id,\r\n      name: serializedProject.name,\r\n      thumbnail: serializedProject.thumbnail,\r\n      createdAt: new Date(serializedProject.createdAt),\r\n      updatedAt: new Date(serializedProject.updatedAt),\r\n      backgroundColor: serializedProject.backgroundColor,\r\n      backgroundType: serializedProject.backgroundType,\r\n      blurIntensity: serializedProject.blurIntensity,\r\n      bookmarks: serializedProject.bookmarks,\r\n      fps: serializedProject.fps,\r\n      canvasSize: serializedProject.canvasSize,\r\n      canvasMode: serializedProject.canvasMode,\r\n    };\r\n  }\r\n\r\n  async loadAllProjects(): Promise<TProject[]> {\r\n    const projectIds = await this.projectsAdapter.list();\r\n    const projects: TProject[] = [];\r\n\r\n    for (const id of projectIds) {\r\n      const project = await this.loadProject(id);\r\n      if (project) {\r\n        projects.push(project);\r\n      }\r\n    }\r\n\r\n    // Sort by last updated (most recent first)\r\n    return projects.sort(\r\n      (a, b) => b.updatedAt.getTime() - a.updatedAt.getTime()\r\n    );\r\n  }\r\n\r\n  async deleteProject(id: string): Promise<void> {\r\n    await this.projectsAdapter.remove(id);\r\n  }\r\n\r\n  // Media operations - now project-specific\r\n  async saveMediaItem(projectId: string, mediaItem: MediaItem): Promise<void> {\r\n    const { mediaMetadataAdapter, mediaFilesAdapter } =\r\n      this.getProjectMediaAdapters(projectId);\r\n\r\n    // Save file to project-specific OPFS\r\n    await mediaFilesAdapter.set(mediaItem.id, mediaItem.file);\r\n\r\n    // Save metadata to project-specific IndexedDB\r\n    const metadata: MediaFileData = {\r\n      id: mediaItem.id,\r\n      name: mediaItem.name,\r\n      type: mediaItem.type,\r\n      size: mediaItem.file.size,\r\n      lastModified: mediaItem.file.lastModified,\r\n      width: mediaItem.width,\r\n      height: mediaItem.height,\r\n      duration: mediaItem.duration,\r\n    };\r\n\r\n    await mediaMetadataAdapter.set(mediaItem.id, metadata);\r\n  }\r\n\r\n  async loadMediaItem(\r\n    projectId: string,\r\n    id: string\r\n  ): Promise<MediaItem | null> {\r\n    const { mediaMetadataAdapter, mediaFilesAdapter } =\r\n      this.getProjectMediaAdapters(projectId);\r\n\r\n    const [file, metadata] = await Promise.all([\r\n      mediaFilesAdapter.get(id),\r\n      mediaMetadataAdapter.get(id),\r\n    ]);\r\n\r\n    if (!file || !metadata) return null;\r\n\r\n    // Create new object URL for the file\r\n    const url = URL.createObjectURL(file);\r\n\r\n    return {\r\n      id: metadata.id,\r\n      name: metadata.name,\r\n      type: metadata.type,\r\n      file,\r\n      url,\r\n      width: metadata.width,\r\n      height: metadata.height,\r\n      duration: metadata.duration,\r\n      // thumbnailUrl would need to be regenerated or cached separately\r\n    };\r\n  }\r\n\r\n  async loadAllMediaItems(projectId: string): Promise<MediaItem[]> {\r\n    const { mediaMetadataAdapter } = this.getProjectMediaAdapters(projectId);\r\n\r\n    const mediaIds = await mediaMetadataAdapter.list();\r\n    const mediaItems: MediaItem[] = [];\r\n\r\n    for (const id of mediaIds) {\r\n      const item = await this.loadMediaItem(projectId, id);\r\n      if (item) {\r\n        mediaItems.push(item);\r\n      }\r\n    }\r\n\r\n    return mediaItems;\r\n  }\r\n\r\n  async deleteMediaItem(projectId: string, id: string): Promise<void> {\r\n    const { mediaMetadataAdapter, mediaFilesAdapter } =\r\n      this.getProjectMediaAdapters(projectId);\r\n\r\n    await Promise.all([\r\n      mediaFilesAdapter.remove(id),\r\n      mediaMetadataAdapter.remove(id),\r\n    ]);\r\n  }\r\n\r\n  async deleteProjectMedia(projectId: string): Promise<void> {\r\n    const { mediaMetadataAdapter, mediaFilesAdapter } =\r\n      this.getProjectMediaAdapters(projectId);\r\n\r\n    await Promise.all([\r\n      mediaMetadataAdapter.clear(),\r\n      mediaFilesAdapter.clear(),\r\n    ]);\r\n  }\r\n\r\n  // Timeline operations - now project-specific\r\n  async saveTimeline(\r\n    projectId: string,\r\n    tracks: TimelineTrack[]\r\n  ): Promise<void> {\r\n    const timelineAdapter = this.getProjectTimelineAdapter(projectId);\r\n    const timelineData: TimelineData = {\r\n      tracks,\r\n      lastModified: new Date().toISOString(),\r\n    };\r\n    await timelineAdapter.set(\"timeline\", timelineData);\r\n  }\r\n\r\n  async loadTimeline(projectId: string): Promise<TimelineTrack[] | null> {\r\n    const timelineAdapter = this.getProjectTimelineAdapter(projectId);\r\n    const timelineData = await timelineAdapter.get(\"timeline\");\r\n    return timelineData ? timelineData.tracks : null;\r\n  }\r\n\r\n  async deleteProjectTimeline(projectId: string): Promise<void> {\r\n    const timelineAdapter = this.getProjectTimelineAdapter(projectId);\r\n    await timelineAdapter.remove(\"timeline\");\r\n  }\r\n\r\n  // Utility methods\r\n  async clearAllData(): Promise<void> {\r\n    // Clear all projects\r\n    await this.projectsAdapter.clear();\r\n\r\n    // Note: Project-specific media and timelines will be cleaned up when projects are deleted\r\n  }\r\n\r\n  async getStorageInfo(): Promise<{\r\n    projects: number;\r\n    isOPFSSupported: boolean;\r\n    isIndexedDBSupported: boolean;\r\n  }> {\r\n    const projectIds = await this.projectsAdapter.list();\r\n\r\n    return {\r\n      projects: projectIds.length,\r\n      isOPFSSupported: this.isOPFSSupported(),\r\n      isIndexedDBSupported: this.isIndexedDBSupported(),\r\n    };\r\n  }\r\n\r\n  async getProjectStorageInfo(projectId: string): Promise<{\r\n    mediaItems: number;\r\n    hasTimeline: boolean;\r\n  }> {\r\n    const { mediaMetadataAdapter } = this.getProjectMediaAdapters(projectId);\r\n    const timelineAdapter = this.getProjectTimelineAdapter(projectId);\r\n\r\n    const [mediaIds, timelineData] = await Promise.all([\r\n      mediaMetadataAdapter.list(),\r\n      timelineAdapter.get(\"timeline\"),\r\n    ]);\r\n\r\n    return {\r\n      mediaItems: mediaIds.length,\r\n      hasTimeline: !!timelineData,\r\n    };\r\n  }\r\n\r\n  async loadSavedSounds(): Promise<SavedSoundsData> {\r\n    try {\r\n      const savedSoundsData = await this.savedSoundsAdapter.get(\"user-sounds\");\r\n      return (\r\n        savedSoundsData || {\r\n          sounds: [],\r\n          lastModified: new Date().toISOString(),\r\n        }\r\n      );\r\n    } catch (error) {\r\n      console.error(\"Failed to load saved sounds:\", error);\r\n      return { sounds: [], lastModified: new Date().toISOString() };\r\n    }\r\n  }\r\n\r\n  async saveSoundEffect(soundEffect: SoundEffect): Promise<void> {\r\n    try {\r\n      const currentData = await this.loadSavedSounds();\r\n\r\n      // Check if sound is already saved\r\n      if (currentData.sounds.some((sound) => sound.id === soundEffect.id)) {\r\n        return; // Already saved\r\n      }\r\n\r\n      const savedSound: SavedSound = {\r\n        id: soundEffect.id,\r\n        name: soundEffect.name,\r\n        username: soundEffect.username,\r\n        previewUrl: soundEffect.previewUrl,\r\n        downloadUrl: soundEffect.downloadUrl,\r\n        duration: soundEffect.duration,\r\n        tags: soundEffect.tags,\r\n        license: soundEffect.license,\r\n        savedAt: new Date().toISOString(),\r\n      };\r\n\r\n      const updatedData: SavedSoundsData = {\r\n        sounds: [...currentData.sounds, savedSound],\r\n        lastModified: new Date().toISOString(),\r\n      };\r\n\r\n      await this.savedSoundsAdapter.set(\"user-sounds\", updatedData);\r\n    } catch (error) {\r\n      console.error(\"Failed to save sound effect:\", error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async removeSavedSound(soundId: number): Promise<void> {\r\n    try {\r\n      const currentData = await this.loadSavedSounds();\r\n\r\n      const updatedData: SavedSoundsData = {\r\n        sounds: currentData.sounds.filter((sound) => sound.id !== soundId),\r\n        lastModified: new Date().toISOString(),\r\n      };\r\n\r\n      await this.savedSoundsAdapter.set(\"user-sounds\", updatedData);\r\n    } catch (error) {\r\n      console.error(\"Failed to remove saved sound:\", error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async isSoundSaved(soundId: number): Promise<boolean> {\r\n    try {\r\n      const currentData = await this.loadSavedSounds();\r\n      return currentData.sounds.some((sound) => sound.id === soundId);\r\n    } catch (error) {\r\n      console.error(\"Failed to check if sound is saved:\", error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async clearSavedSounds(): Promise<void> {\r\n    try {\r\n      await this.savedSoundsAdapter.remove(\"user-sounds\");\r\n    } catch (error) {\r\n      console.error(\"Failed to clear saved sounds:\", error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Check browser support\r\n  isOPFSSupported(): boolean {\r\n    return OPFSAdapter.isSupported();\r\n  }\r\n\r\n  isIndexedDBSupported(): boolean {\r\n    return \"indexedDB\" in window;\r\n  }\r\n\r\n  isFullySupported(): boolean {\r\n    return this.isIndexedDBSupported() && this.isOPFSSupported();\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const storageService = new StorageService();\r\nexport { StorageService };\r\n","import { create } from \"zustand\";\r\nimport { storageService } from \"@/lib/storage/storage-service\";\r\nimport { useTimelineStore } from \"./timeline-store\";\r\nimport { generateUUID } from \"@/lib/utils\";\r\n\r\nexport type MediaType = \"image\" | \"video\" | \"audio\";\r\n\r\nexport interface MediaItem {\r\n  id: string;\r\n  name: string;\r\n  type: MediaType;\r\n  file: File;\r\n  url?: string; // Object URL for preview\r\n  thumbnailUrl?: string; // For video thumbnails\r\n  duration?: number; // For video/audio duration\r\n  width?: number; // For video/image width\r\n  height?: number; // For video/image height\r\n  fps?: number; // For video frame rate\r\n  // Text-specific properties\r\n  content?: string; // Text content\r\n  fontSize?: number; // Font size\r\n  fontFamily?: string; // Font family\r\n  color?: string; // Text color\r\n  backgroundColor?: string; // Background color\r\n  textAlign?: \"left\" | \"center\" | \"right\"; // Text alignment\r\n}\r\n\r\ninterface MediaStore {\r\n  mediaItems: MediaItem[];\r\n  isLoading: boolean;\r\n\r\n  // Actions - now require projectId\r\n  addMediaItem: (\r\n    projectId: string,\r\n    item: Omit<MediaItem, \"id\">\r\n  ) => Promise<void>;\r\n  removeMediaItem: (projectId: string, id: string) => Promise<void>;\r\n  loadProjectMedia: (projectId: string) => Promise<void>;\r\n  clearProjectMedia: (projectId: string) => Promise<void>;\r\n  clearAllMedia: () => void; // Clear local state only\r\n}\r\n\r\n// Helper function to determine file type\r\nexport const getFileType = (file: File): MediaType | null => {\r\n  const { type } = file;\r\n\r\n  if (type.startsWith(\"image/\")) {\r\n    return \"image\";\r\n  }\r\n  if (type.startsWith(\"video/\")) {\r\n    return \"video\";\r\n  }\r\n  if (type.startsWith(\"audio/\")) {\r\n    return \"audio\";\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\n// Helper function to get image dimensions\r\nexport const getImageDimensions = (\r\n  file: File\r\n): Promise<{ width: number; height: number }> => {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new window.Image();\r\n\r\n    img.addEventListener(\"load\", () => {\r\n      const width = img.naturalWidth;\r\n      const height = img.naturalHeight;\r\n      resolve({ width, height });\r\n      img.remove();\r\n    });\r\n\r\n    img.addEventListener(\"error\", () => {\r\n      reject(new Error(\"Could not load image\"));\r\n      img.remove();\r\n    });\r\n\r\n    img.src = URL.createObjectURL(file);\r\n  });\r\n};\r\n\r\n// Helper function to generate video thumbnail and get dimensions\r\nexport const generateVideoThumbnail = (\r\n  file: File\r\n): Promise<{ thumbnailUrl: string; width: number; height: number }> => {\r\n  return new Promise((resolve, reject) => {\r\n    const video = document.createElement(\"video\") as HTMLVideoElement;\r\n    const canvas = document.createElement(\"canvas\") as HTMLCanvasElement;\r\n    const ctx = canvas.getContext(\"2d\");\r\n\r\n    if (!ctx) {\r\n      reject(new Error(\"Could not get canvas context\"));\r\n      return;\r\n    }\r\n\r\n    video.addEventListener(\"loadedmetadata\", () => {\r\n      canvas.width = video.videoWidth;\r\n      canvas.height = video.videoHeight;\r\n\r\n      // Seek to 1 second or 10% of duration, whichever is smaller\r\n      video.currentTime = Math.min(1, video.duration * 0.1);\r\n    });\r\n\r\n    video.addEventListener(\"seeked\", () => {\r\n      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n      const thumbnailUrl = canvas.toDataURL(\"image/jpeg\", 0.8);\r\n      const width = video.videoWidth;\r\n      const height = video.videoHeight;\r\n\r\n      resolve({ thumbnailUrl, width, height });\r\n\r\n      // Cleanup\r\n      video.remove();\r\n      canvas.remove();\r\n    });\r\n\r\n    video.addEventListener(\"error\", () => {\r\n      reject(new Error(\"Could not load video\"));\r\n      video.remove();\r\n      canvas.remove();\r\n    });\r\n\r\n    video.src = URL.createObjectURL(file);\r\n    video.load();\r\n  });\r\n};\r\n\r\n// Helper function to get media duration\r\nexport const getMediaDuration = (file: File): Promise<number> => {\r\n  return new Promise((resolve, reject) => {\r\n    const element = document.createElement(\r\n      file.type.startsWith(\"video/\") ? \"video\" : \"audio\"\r\n    ) as HTMLVideoElement;\r\n\r\n    element.addEventListener(\"loadedmetadata\", () => {\r\n      resolve(element.duration);\r\n      element.remove();\r\n    });\r\n\r\n    element.addEventListener(\"error\", () => {\r\n      reject(new Error(\"Could not load media\"));\r\n      element.remove();\r\n    });\r\n\r\n    element.src = URL.createObjectURL(file);\r\n    element.load();\r\n  });\r\n};\r\n\r\n// Helper to get aspect ratio from MediaItem\r\nexport const getMediaAspectRatio = (item: MediaItem): number => {\r\n  if (item.width && item.height) {\r\n    return item.width / item.height;\r\n  }\r\n  return 16 / 9; // Default aspect ratio\r\n};\r\n\r\nexport const useMediaStore = create<MediaStore>((set, get) => ({\r\n  mediaItems: [],\r\n  isLoading: false,\r\n\r\n  addMediaItem: async (projectId, item) => {\r\n    const newItem: MediaItem = {\r\n      ...item,\r\n      id: generateUUID(),\r\n    };\r\n\r\n    // Add to local state immediately for UI responsiveness\r\n    set((state) => ({\r\n      mediaItems: [...state.mediaItems, newItem],\r\n    }));\r\n\r\n    // Save to persistent storage in background\r\n    try {\r\n      await storageService.saveMediaItem(projectId, newItem);\r\n    } catch (error) {\r\n      console.error(\"Failed to save media item:\", error);\r\n      // Remove from local state if save failed\r\n      set((state) => ({\r\n        mediaItems: state.mediaItems.filter((media) => media.id !== newItem.id),\r\n      }));\r\n    }\r\n  },\r\n\r\n  removeMediaItem: async (projectId: string, id: string) => {\r\n    const state = get();\r\n    const item = state.mediaItems.find((media) => media.id === id);\r\n\r\n    // Cleanup object URLs to prevent memory leaks\r\n    if (item?.url) {\r\n      URL.revokeObjectURL(item.url);\r\n      if (item.thumbnailUrl) {\r\n        URL.revokeObjectURL(item.thumbnailUrl);\r\n      }\r\n    }\r\n\r\n    // 1) Remove from local state immediately\r\n    set((state) => ({\r\n      mediaItems: state.mediaItems.filter((media) => media.id !== id),\r\n    }));\r\n\r\n    // 2) Cascade into the timeline: remove any elements using this media ID\r\n    const timeline = useTimelineStore.getState();\r\n    const {\r\n      tracks,\r\n      removeElementFromTrack,\r\n      removeElementFromTrackWithRipple,\r\n      rippleEditingEnabled,\r\n      pushHistory,\r\n    } = timeline;\r\n\r\n    // Find all elements that reference this media\r\n    const elementsToRemove: Array<{ trackId: string; elementId: string }> = [];\r\n    for (const track of tracks) {\r\n      for (const el of track.elements) {\r\n        if (el.type === \"media\" && el.mediaId === id) {\r\n          elementsToRemove.push({ trackId: track.id, elementId: el.id });\r\n        }\r\n      }\r\n    }\r\n\r\n    // If there are elements to remove, push history once before batch removal\r\n    if (elementsToRemove.length > 0) {\r\n      pushHistory();\r\n\r\n      // Remove all elements without pushing additional history entries\r\n      for (const { trackId, elementId } of elementsToRemove) {\r\n        if (rippleEditingEnabled) {\r\n          removeElementFromTrackWithRipple(trackId, elementId, false);\r\n        } else {\r\n          removeElementFromTrack(trackId, elementId, false);\r\n        }\r\n      }\r\n    }\r\n\r\n    // 3) Remove from persistent storage\r\n    try {\r\n      await storageService.deleteMediaItem(projectId, id);\r\n    } catch (error) {\r\n      console.error(\"Failed to delete media item:\", error);\r\n    }\r\n  },\r\n\r\n  loadProjectMedia: async (projectId) => {\r\n    set({ isLoading: true });\r\n\r\n    try {\r\n      const mediaItems = await storageService.loadAllMediaItems(projectId);\r\n\r\n      // Regenerate thumbnails for video items\r\n      const updatedMediaItems = await Promise.all(\r\n        mediaItems.map(async (item) => {\r\n          if (item.type === \"video\" && item.file) {\r\n            try {\r\n              const { thumbnailUrl, width, height } =\r\n                await generateVideoThumbnail(item.file);\r\n              return {\r\n                ...item,\r\n                thumbnailUrl,\r\n                width: width || item.width,\r\n                height: height || item.height,\r\n              };\r\n            } catch (error) {\r\n              console.error(\r\n                `Failed to regenerate thumbnail for video ${item.id}:`,\r\n                error\r\n              );\r\n              return item;\r\n            }\r\n          }\r\n          return item;\r\n        })\r\n      );\r\n\r\n      set({ mediaItems: updatedMediaItems });\r\n    } catch (error) {\r\n      console.error(\"Failed to load media items:\", error);\r\n    } finally {\r\n      set({ isLoading: false });\r\n    }\r\n  },\r\n\r\n  clearProjectMedia: async (projectId) => {\r\n    const state = get();\r\n\r\n    // Cleanup all object URLs\r\n    state.mediaItems.forEach((item) => {\r\n      if (item.url) {\r\n        URL.revokeObjectURL(item.url);\r\n      }\r\n      if (item.thumbnailUrl) {\r\n        URL.revokeObjectURL(item.thumbnailUrl);\r\n      }\r\n    });\r\n\r\n    // Clear local state\r\n    set({ mediaItems: [] });\r\n\r\n    // Clear persistent storage\r\n    try {\r\n      const mediaIds = state.mediaItems.map((item) => item.id);\r\n      await Promise.all(\r\n        mediaIds.map((id) => storageService.deleteMediaItem(projectId, id))\r\n      );\r\n    } catch (error) {\r\n      console.error(\"Failed to clear media items from storage:\", error);\r\n    }\r\n  },\r\n\r\n  clearAllMedia: () => {\r\n    const state = get();\r\n\r\n    // Cleanup all object URLs\r\n    state.mediaItems.forEach((item) => {\r\n      if (item.url) {\r\n        URL.revokeObjectURL(item.url);\r\n      }\r\n      if (item.thumbnailUrl) {\r\n        URL.revokeObjectURL(item.thumbnailUrl);\r\n      }\r\n    });\r\n\r\n    // Clear local state\r\n    set({ mediaItems: [] });\r\n  },\r\n}));\r\n","import { TProject } from \"@/types/project\";\r\nimport { create } from \"zustand\";\r\nimport { storageService } from \"@/lib/storage/storage-service\";\r\nimport { toast } from \"sonner\";\r\nimport { useMediaStore } from \"./media-store\";\r\nimport { useTimelineStore } from \"./timeline-store\";\r\nimport { generateUUID } from \"@/lib/utils\";\r\nimport { CanvasSize, CanvasMode } from \"@/types/editor\";\r\n\r\nexport const DEFAULT_CANVAS_SIZE: CanvasSize = { width: 1920, height: 1080 };\r\n\r\nconst DEFAULT_PROJECT: TProject = {\r\n  id: generateUUID(),\r\n  name: \"Untitled\",\r\n  thumbnail: \"\",\r\n  createdAt: new Date(),\r\n  updatedAt: new Date(),\r\n  backgroundColor: \"#000000\",\r\n  backgroundType: \"color\",\r\n  blurIntensity: 8,\r\n  bookmarks: [],\r\n  fps: 30,\r\n  canvasSize: DEFAULT_CANVAS_SIZE,\r\n  canvasMode: \"preset\",\r\n};\r\n\r\ninterface ProjectStore {\r\n  activeProject: TProject | null;\r\n  savedProjects: TProject[];\r\n  isLoading: boolean;\r\n  isInitialized: boolean;\r\n  invalidProjectIds?: Set<string>;\r\n\r\n  // Actions\r\n  createNewProject: (name: string) => Promise<string>;\r\n  loadProject: (id: string) => Promise<void>;\r\n  saveCurrentProject: () => Promise<void>;\r\n  loadAllProjects: () => Promise<void>;\r\n  deleteProject: (id: string) => Promise<void>;\r\n  closeProject: () => void;\r\n  renameProject: (projectId: string, name: string) => Promise<void>;\r\n  duplicateProject: (projectId: string) => Promise<string>;\r\n  updateProjectBackground: (backgroundColor: string) => Promise<void>;\r\n  updateBackgroundType: (\r\n    type: \"color\" | \"blur\",\r\n    options?: { backgroundColor?: string; blurIntensity?: number }\r\n  ) => Promise<void>;\r\n  updateProjectFps: (fps: number) => Promise<void>;\r\n  updateCanvasSize: (size: CanvasSize, mode: CanvasMode) => Promise<void>;\r\n\r\n  // Bookmark methods\r\n  toggleBookmark: (time: number) => Promise<void>;\r\n  isBookmarked: (time: number) => boolean;\r\n  removeBookmark: (time: number) => Promise<void>;\r\n\r\n  getFilteredAndSortedProjects: (\r\n    searchQuery: string,\r\n    sortOption: string\r\n  ) => TProject[];\r\n\r\n  // Global invalid project ID tracking\r\n  isInvalidProjectId: (id: string) => boolean;\r\n  markProjectIdAsInvalid: (id: string) => void;\r\n  clearInvalidProjectIds: () => void;\r\n}\r\n\r\nexport const useProjectStore = create<ProjectStore>((set, get) => ({\r\n  activeProject: null,\r\n  savedProjects: [],\r\n  isLoading: true,\r\n  isInitialized: false,\r\n  invalidProjectIds: new Set<string>(),\r\n\r\n  // Implementation of bookmark methods\r\n  toggleBookmark: async (time: number) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    // Round time to the nearest frame\r\n    const fps = activeProject.fps || 30;\r\n    const frameTime = Math.round(time * fps) / fps;\r\n\r\n    const bookmarks = activeProject.bookmarks || [];\r\n    let updatedBookmarks: number[];\r\n\r\n    // Check if already bookmarked\r\n    const bookmarkIndex = bookmarks.findIndex(\r\n      (bookmark) => Math.abs(bookmark - frameTime) < 0.001\r\n    );\r\n\r\n    if (bookmarkIndex !== -1) {\r\n      // Remove bookmark\r\n      updatedBookmarks = bookmarks.filter((_, i) => i !== bookmarkIndex);\r\n    } else {\r\n      // Add bookmark\r\n      updatedBookmarks = [...bookmarks, frameTime].sort((a, b) => a - b);\r\n    }\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      bookmarks: updatedBookmarks,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update project bookmarks:\", error);\r\n      toast.error(\"Failed to update bookmarks\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  isBookmarked: (time: number) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject || !activeProject.bookmarks) return false;\r\n\r\n    // Round time to the nearest frame\r\n    const fps = activeProject.fps || 30;\r\n    const frameTime = Math.round(time * fps) / fps;\r\n\r\n    return activeProject.bookmarks.some(\r\n      (bookmark) => Math.abs(bookmark - frameTime) < 0.001\r\n    );\r\n  },\r\n\r\n  removeBookmark: async (time: number) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject || !activeProject.bookmarks) return;\r\n\r\n    // Round time to the nearest frame\r\n    const fps = activeProject.fps || 30;\r\n    const frameTime = Math.round(time * fps) / fps;\r\n\r\n    const updatedBookmarks = activeProject.bookmarks.filter(\r\n      (bookmark) => Math.abs(bookmark - frameTime) >= 0.001\r\n    );\r\n\r\n    if (updatedBookmarks.length === activeProject.bookmarks.length) {\r\n      // No bookmark found to remove\r\n      return;\r\n    }\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      bookmarks: updatedBookmarks,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update project bookmarks:\", error);\r\n      toast.error(\"Failed to remove bookmark\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  createNewProject: async (name: string) => {\r\n    const newProject: TProject = { ...DEFAULT_PROJECT, name };\r\n\r\n    set({ activeProject: newProject });\r\n\r\n    try {\r\n      await storageService.saveProject(newProject);\r\n      // Reload all projects to update the list\r\n      await get().loadAllProjects();\r\n      return newProject.id;\r\n    } catch (error) {\r\n      toast.error(\"Failed to save new project\");\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  loadProject: async (id: string) => {\r\n    if (!get().isInitialized) {\r\n      set({ isLoading: true });\r\n    }\r\n\r\n    // Clear media and timeline immediately to prevent flickering when switching projects\r\n    const mediaStore = useMediaStore.getState();\r\n    const timelineStore = useTimelineStore.getState();\r\n    mediaStore.clearAllMedia();\r\n    timelineStore.clearTimeline();\r\n\r\n    try {\r\n      const project = await storageService.loadProject(id);\r\n      if (project) {\r\n        set({ activeProject: project });\r\n\r\n        // Load project-specific data in parallel\r\n        await Promise.all([\r\n          mediaStore.loadProjectMedia(id),\r\n          timelineStore.loadProjectTimeline(id),\r\n        ]);\r\n      } else {\r\n        throw new Error(`Project with id ${id} not found`);\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Failed to load project:\", error);\r\n      throw error; // Re-throw so the editor page can handle it\r\n    } finally {\r\n      set({ isLoading: false });\r\n    }\r\n  },\r\n\r\n  saveCurrentProject: async () => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    try {\r\n      // Save project metadata and timeline data in parallel\r\n      const timelineStore = useTimelineStore.getState();\r\n      await Promise.all([\r\n        storageService.saveProject(activeProject),\r\n        timelineStore.saveProjectTimeline(activeProject.id),\r\n      ]);\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to save project:\", error);\r\n    }\r\n  },\r\n\r\n  loadAllProjects: async () => {\r\n    if (!get().isInitialized) {\r\n      set({ isLoading: true });\r\n    }\r\n\r\n    try {\r\n      const projects = await storageService.loadAllProjects();\r\n      set({ savedProjects: projects });\r\n    } catch (error) {\r\n      console.error(\"Failed to load projects:\", error);\r\n    } finally {\r\n      set({ isLoading: false, isInitialized: true });\r\n    }\r\n  },\r\n\r\n  deleteProject: async (id: string) => {\r\n    try {\r\n      // Delete project data in parallel\r\n      await Promise.all([\r\n        storageService.deleteProjectMedia(id),\r\n        storageService.deleteProjectTimeline(id),\r\n        storageService.deleteProject(id),\r\n      ]);\r\n      await get().loadAllProjects(); // Refresh the list\r\n\r\n      // If we deleted the active project, close it and clear data\r\n      const { activeProject } = get();\r\n      if (activeProject?.id === id) {\r\n        set({ activeProject: null });\r\n        const mediaStore = useMediaStore.getState();\r\n        const timelineStore = useTimelineStore.getState();\r\n        mediaStore.clearAllMedia();\r\n        timelineStore.clearTimeline();\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Failed to delete project:\", error);\r\n    }\r\n  },\r\n\r\n  closeProject: () => {\r\n    set({ activeProject: null });\r\n\r\n    // Clear data from stores when closing project\r\n    const mediaStore = useMediaStore.getState();\r\n    const timelineStore = useTimelineStore.getState();\r\n    mediaStore.clearAllMedia();\r\n    timelineStore.clearTimeline();\r\n  },\r\n\r\n  renameProject: async (id: string, name: string) => {\r\n    const { savedProjects } = get();\r\n\r\n    // Find the project to rename\r\n    const projectToRename = savedProjects.find((p) => p.id === id);\r\n    if (!projectToRename) {\r\n      toast.error(\"Project not found\", {\r\n        description: \"Please try again\",\r\n      });\r\n      return;\r\n    }\r\n\r\n    const updatedProject = {\r\n      ...projectToRename,\r\n      name,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      // Save to storage\r\n      await storageService.saveProject(updatedProject);\r\n\r\n      await get().loadAllProjects();\r\n\r\n      // Update activeProject if it's the same project\r\n      const { activeProject } = get();\r\n      if (activeProject?.id === id) {\r\n        set({ activeProject: updatedProject });\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Failed to rename project:\", error);\r\n      toast.error(\"Failed to rename project\", {\r\n        description:\r\n          error instanceof Error ? error.message : \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  duplicateProject: async (projectId: string) => {\r\n    try {\r\n      const project = await storageService.loadProject(projectId);\r\n      if (!project) {\r\n        toast.error(\"Project not found\", {\r\n          description: \"Please try again\",\r\n        });\r\n        throw new Error(\"Project not found\");\r\n      }\r\n\r\n      const { savedProjects } = get();\r\n\r\n      // Extract the base name (remove any existing numbering)\r\n      const numberMatch = project.name.match(/^\\((\\d+)\\)\\s+(.+)$/);\r\n      const baseName = numberMatch ? numberMatch[2] : project.name;\r\n      const existingNumbers: number[] = [];\r\n\r\n      // Check for pattern \"(number) baseName\" in existing projects\r\n      savedProjects.forEach((p) => {\r\n        const match = p.name.match(/^\\((\\d+)\\)\\s+(.+)$/);\r\n        if (match && match[2] === baseName) {\r\n          existingNumbers.push(parseInt(match[1], 10));\r\n        }\r\n      });\r\n\r\n      const nextNumber =\r\n        existingNumbers.length > 0 ? Math.max(...existingNumbers) + 1 : 1;\r\n\r\n      const newProject: TProject = {\r\n        ...project, // Copy all properties from the original project\r\n        id: generateUUID(),\r\n        name: `(${nextNumber}) ${baseName}`,\r\n        createdAt: new Date(),\r\n        updatedAt: new Date(),\r\n      };\r\n\r\n      await storageService.saveProject(newProject);\r\n      await get().loadAllProjects();\r\n      return newProject.id;\r\n    } catch (error) {\r\n      console.error(\"Failed to duplicate project:\", error);\r\n      toast.error(\"Failed to duplicate project\", {\r\n        description:\r\n          error instanceof Error ? error.message : \"Please try again\",\r\n      });\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  updateProjectBackground: async (backgroundColor: string) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      backgroundColor,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update project background:\", error);\r\n      toast.error(\"Failed to update background\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  updateBackgroundType: async (\r\n    type: \"color\" | \"blur\",\r\n    options?: { backgroundColor?: string; blurIntensity?: number }\r\n  ) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      backgroundType: type,\r\n      ...(options?.backgroundColor && {\r\n        backgroundColor: options.backgroundColor,\r\n      }),\r\n      ...(options?.blurIntensity && { blurIntensity: options.blurIntensity }),\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update background type:\", error);\r\n      toast.error(\"Failed to update background\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  updateProjectFps: async (fps: number) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      fps,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update project FPS:\", error);\r\n      toast.error(\"Failed to update project FPS\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  updateCanvasSize: async (size: CanvasSize, mode: CanvasMode) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      canvasSize: size,\r\n      canvasMode: mode,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update canvas size:\", error);\r\n      toast.error(\"Failed to update canvas size\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  getFilteredAndSortedProjects: (searchQuery: string, sortOption: string) => {\r\n    const { savedProjects } = get();\r\n\r\n    // Filter projects by search query\r\n    const filteredProjects = savedProjects.filter((project) =>\r\n      project.name.toLowerCase().includes(searchQuery.toLowerCase())\r\n    );\r\n\r\n    // Sort filtered projects\r\n    const sortedProjects = [...filteredProjects].sort((a, b) => {\r\n      const [key, order] = sortOption.split(\"-\");\r\n\r\n      if (key !== \"createdAt\" && key !== \"name\") {\r\n        console.warn(`Invalid sort key: ${key}`);\r\n        return 0;\r\n      }\r\n\r\n      const aValue = a[key];\r\n      const bValue = b[key];\r\n\r\n      if (aValue === undefined || bValue === undefined) return 0;\r\n\r\n      if (order === \"asc\") {\r\n        if (aValue < bValue) return -1;\r\n        if (aValue > bValue) return 1;\r\n        return 0;\r\n      }\r\n      if (aValue > bValue) return -1;\r\n      if (aValue < bValue) return 1;\r\n      return 0;\r\n    });\r\n\r\n    return sortedProjects;\r\n  },\r\n\r\n  // Global invalid project ID tracking implementation\r\n  isInvalidProjectId: (id: string) => {\r\n    const invalidIds = get().invalidProjectIds || new Set();\r\n    return invalidIds.has(id);\r\n  },\r\n\r\n  markProjectIdAsInvalid: (id: string) => {\r\n    set((state) => ({\r\n      invalidProjectIds: new Set([\r\n        ...(state.invalidProjectIds || new Set()),\r\n        id,\r\n      ]),\r\n    }));\r\n  },\r\n\r\n  clearInvalidProjectIds: () => {\r\n    set({ invalidProjectIds: new Set() });\r\n  },\r\n}));\r\n","import type { TrackType } from \"@/types/timeline\";\r\n\r\n// Track color definitions\r\nexport const TRACK_COLORS: Record<\r\n  TrackType,\r\n  { solid: string; background: string; border: string }\r\n> = {\r\n  media: {\r\n    solid: \"bg-blue-500\",\r\n    background: \"\",\r\n    border: \"\",\r\n  },\r\n  text: {\r\n    solid: \"bg-[#5DBAA0]\",\r\n    background: \"bg-[#5DBAA0]\",\r\n    border: \"\",\r\n  },\r\n  audio: {\r\n    solid: \"bg-green-500\",\r\n    background: \"bg-[#915DBE]\",\r\n    border: \"\",\r\n  },\r\n} as const;\r\n\r\n// Utility functions\r\nexport function getTrackColors(type: TrackType) {\r\n  return TRACK_COLORS[type];\r\n}\r\n\r\nexport function getTrackElementClasses(type: TrackType) {\r\n  const colors = getTrackColors(type);\r\n  return `${colors.background} ${colors.border}`;\r\n}\r\n\r\n// Track height definitions\r\nexport const TRACK_HEIGHTS: Record<TrackType, number> = {\r\n  media: 60,\r\n  text: 25,\r\n  audio: 50,\r\n} as const;\r\n\r\n// Utility function for track heights\r\nexport function getTrackHeight(type: TrackType): number {\r\n  return TRACK_HEIGHTS[type];\r\n}\r\n\r\n// Calculate cumulative height up to (but not including) a track index\r\nexport function getCumulativeHeightBefore(\r\n  tracks: Array<{ type: TrackType }>,\r\n  trackIndex: number\r\n): number {\r\n  const GAP = 4; // 4px gap between tracks (equivalent to Tailwind's gap-1)\r\n  return tracks\r\n    .slice(0, trackIndex)\r\n    .reduce((sum, track) => sum + getTrackHeight(track.type) + GAP, 0);\r\n}\r\n\r\n// Calculate total height of all tracks\r\nexport function getTotalTracksHeight(\r\n  tracks: Array<{ type: TrackType }>\r\n): number {\r\n  const GAP = 4; // 4px gap between tracks (equivalent to Tailwind's gap-1)\r\n  const tracksHeight = tracks.reduce(\r\n    (sum, track) => sum + getTrackHeight(track.type),\r\n    0\r\n  );\r\n  const gapsHeight = Math.max(0, tracks.length - 1) * GAP; // n-1 gaps for n tracks\r\n  return tracksHeight + gapsHeight;\r\n}\r\n\r\n// Other timeline constants\r\nexport const TIMELINE_CONSTANTS = {\r\n  ELEMENT_MIN_WIDTH: 80,\r\n  PIXELS_PER_SECOND: 50,\r\n  TRACK_HEIGHT: 60, // Default fallback\r\n  DEFAULT_TEXT_DURATION: 5,\r\n  DEFAULT_IMAGE_DURATION: 5,\r\n  ZOOM_LEVELS: [0.25, 0.5, 1, 1.5, 2, 3, 4],\r\n} as const;\r\n\r\n// FPS presets for project settings\r\nexport const FPS_PRESETS = [\r\n  { value: \"24\", label: \"24 fps\" },\r\n  { value: \"25\", label: \"25 fps\" },\r\n  { value: \"30\", label: \"30 fps\" },\r\n  { value: \"60\", label: \"60 fps\" },\r\n  { value: \"120\", label: \"120 fps\" },\r\n] as const;\r\n\r\n// Frame snapping utilities\r\nexport function timeToFrame(time: number, fps: number): number {\r\n  return Math.round(time * fps);\r\n}\r\n\r\nexport function frameToTime(frame: number, fps: number): number {\r\n  return frame / fps;\r\n}\r\n\r\nexport function snapTimeToFrame(time: number, fps: number): number {\r\n  if (fps <= 0) return time; // Fallback for invalid FPS\r\n  const frame = timeToFrame(time, fps);\r\n  return frameToTime(frame, fps);\r\n}\r\n\r\nexport function getFrameDuration(fps: number): number {\r\n  return 1 / fps;\r\n}\r\n","import { CanvasSize } from \"@/types/editor\";\r\n\r\nconst DEFAULT_CANVAS_PRESETS = [\r\n  { name: \"16:9\", width: 1920, height: 1080 },\r\n  { name: \"9:16\", width: 1080, height: 1920 },\r\n  { name: \"1:1\", width: 1080, height: 1080 },\r\n  { name: \"4:3\", width: 1440, height: 1080 },\r\n];\r\n\r\n/**\r\n * Helper function to find the best matching canvas preset for an aspect ratio\r\n * @param aspectRatio The target aspect ratio to match\r\n * @returns The best matching canvas size\r\n */\r\nexport function findBestCanvasPreset(aspectRatio: number): CanvasSize {\r\n  // Calculate aspect ratio for each preset and find the closest match\r\n  let bestMatch = DEFAULT_CANVAS_PRESETS[0]; // Default to 16:9 HD\r\n  let smallestDifference = Math.abs(\r\n    aspectRatio - bestMatch.width / bestMatch.height\r\n  );\r\n\r\n  for (const preset of DEFAULT_CANVAS_PRESETS) {\r\n    const presetAspectRatio = preset.width / preset.height;\r\n    const difference = Math.abs(aspectRatio - presetAspectRatio);\r\n\r\n    if (difference < smallestDifference) {\r\n      smallestDifference = difference;\r\n      bestMatch = preset;\r\n    }\r\n  }\r\n\r\n  // If the difference is still significant (> 0.1), create a custom size\r\n  // based on the media aspect ratio with a reasonable resolution\r\n  const bestAspectRatio = bestMatch.width / bestMatch.height;\r\n  if (Math.abs(aspectRatio - bestAspectRatio) > 0.1) {\r\n    // Create custom dimensions based on the aspect ratio\r\n    if (aspectRatio > 1) {\r\n      // Landscape - use 1920 width\r\n      return { width: 1920, height: Math.round(1920 / aspectRatio) };\r\n    }\r\n    // Portrait or square - use 1080 height\r\n    return { width: Math.round(1080 * aspectRatio), height: 1080 };\r\n  }\r\n\r\n  return { width: bestMatch.width, height: bestMatch.height };\r\n}\r\n","import { TimelineElement } from \"@/types/timeline\";\r\n\r\n// Helper function to check for element overlaps and prevent invalid timeline states\r\nexport const checkElementOverlaps = (elements: TimelineElement[]): boolean => {\r\n  // Sort elements by start time\r\n  const sortedElements = [...elements].sort(\r\n    (a, b) => a.startTime - b.startTime\r\n  );\r\n\r\n  for (let i = 0; i < sortedElements.length - 1; i++) {\r\n    const current = sortedElements[i];\r\n    const next = sortedElements[i + 1];\r\n\r\n    const currentEnd =\r\n      current.startTime +\r\n      (current.duration - current.trimStart - current.trimEnd);\r\n\r\n    // Check if current element overlaps with next element\r\n    if (currentEnd > next.startTime) return true; // Overlap detected\r\n  }\r\n\r\n  return false; // No overlaps\r\n};\r\n\r\n// Helper function to resolve overlaps by adjusting element positions\r\nexport const resolveElementOverlaps = (\r\n  elements: TimelineElement[]\r\n): TimelineElement[] => {\r\n  // Sort elements by start time\r\n  const sortedElements = [...elements].sort(\r\n    (a, b) => a.startTime - b.startTime\r\n  );\r\n  const resolvedElements: TimelineElement[] = [];\r\n\r\n  for (let i = 0; i < sortedElements.length; i++) {\r\n    const current = { ...sortedElements[i] };\r\n\r\n    if (resolvedElements.length > 0) {\r\n      const previous = resolvedElements[resolvedElements.length - 1];\r\n      const previousEnd =\r\n        previous.startTime +\r\n        (previous.duration - previous.trimStart - previous.trimEnd);\r\n\r\n      // If current element would overlap with previous, push it after previous ends\r\n      if (current.startTime < previousEnd) {\r\n        current.startTime = previousEnd;\r\n      }\r\n    }\r\n\r\n    resolvedElements.push(current);\r\n  }\r\n\r\n  return resolvedElements;\r\n};\r\n","import { create } from \"zustand\";\r\nimport {\r\n  TrackType,\r\n  TimelineElement,\r\n  CreateTimelineElement,\r\n  TimelineTrack,\r\n  TextElement,\r\n  DragData,\r\n  sortTracksByOrder,\r\n  ensureMainTrack,\r\n  validateElementTrackCompatibility,\r\n} from \"@/types/timeline\";\r\nimport {\r\n  useMediaStore,\r\n  getMediaAspectRatio,\r\n  type MediaItem,\r\n} from \"./media-store\";\r\nimport { findBestCanvasPreset } from \"@/lib/editor-utils\";\r\nimport { storageService } from \"@/lib/storage/storage-service\";\r\nimport { useProjectStore } from \"./project-store\";\r\nimport { generateUUID } from \"@/lib/utils\";\r\nimport { TIMELINE_CONSTANTS } from \"@/constants/timeline-constants\";\r\nimport { checkElementOverlaps, resolveElementOverlaps } from \"@/lib/timeline\";\r\n\r\n// Helper function to manage element naming with suffixes\r\nconst getElementNameWithSuffix = (\r\n  originalName: string,\r\n  suffix: string\r\n): string => {\r\n  // Remove existing suffixes to prevent accumulation\r\n  const baseName = originalName\r\n    .replace(/ \\(left\\)$/, \"\")\r\n    .replace(/ \\(right\\)$/, \"\")\r\n    .replace(/ \\(audio\\)$/, \"\")\r\n    .replace(/ \\(split \\d+\\)$/, \"\");\r\n\r\n  return `${baseName} (${suffix})`;\r\n};\r\n\r\ninterface TimelineStore {\r\n  // Private track storage\r\n  _tracks: TimelineTrack[];\r\n  history: TimelineTrack[][];\r\n  redoStack: TimelineTrack[][];\r\n\r\n  // Always returns properly ordered tracks with main track ensured\r\n  tracks: TimelineTrack[];\r\n\r\n  // Manual method if you need to force recomputation\r\n  getSortedTracks: () => TimelineTrack[];\r\n\r\n  // Snapping settings\r\n  snappingEnabled: boolean;\r\n\r\n  // Snapping actions\r\n  toggleSnapping: () => void;\r\n\r\n  // Ripple editing mode\r\n  rippleEditingEnabled: boolean;\r\n  toggleRippleEditing: () => void;\r\n\r\n  // Multi-selection\r\n  selectedElements: { trackId: string; elementId: string }[];\r\n  selectElement: (trackId: string, elementId: string, multi?: boolean) => void;\r\n  deselectElement: (trackId: string, elementId: string) => void;\r\n  clearSelectedElements: () => void;\r\n  setSelectedElements: (\r\n    elements: { trackId: string; elementId: string }[]\r\n  ) => void;\r\n\r\n  // Drag state\r\n  dragState: {\r\n    isDragging: boolean;\r\n    elementId: string | null;\r\n    trackId: string | null;\r\n    startMouseX: number;\r\n    startElementTime: number;\r\n    clickOffsetTime: number;\r\n    currentTime: number;\r\n  };\r\n  setDragState: (dragState: Partial<TimelineStore[\"dragState\"]>) => void;\r\n  startDrag: (\r\n    elementId: string,\r\n    trackId: string,\r\n    startMouseX: number,\r\n    startElementTime: number,\r\n    clickOffsetTime: number\r\n  ) => void;\r\n  updateDragTime: (currentTime: number) => void;\r\n  endDrag: () => void;\r\n\r\n  // Actions\r\n  addTrack: (type: TrackType) => string;\r\n  insertTrackAt: (type: TrackType, index: number) => string;\r\n  removeTrack: (trackId: string) => void;\r\n  removeTrackWithRipple: (trackId: string) => void;\r\n  addElementToTrack: (trackId: string, element: CreateTimelineElement) => void;\r\n  removeElementFromTrack: (\r\n    trackId: string,\r\n    elementId: string,\r\n    pushHistory?: boolean\r\n  ) => void;\r\n  moveElementToTrack: (\r\n    fromTrackId: string,\r\n    toTrackId: string,\r\n    elementId: string\r\n  ) => void;\r\n  updateElementTrim: (\r\n    trackId: string,\r\n    elementId: string,\r\n    trimStart: number,\r\n    trimEnd: number,\r\n    pushHistory?: boolean\r\n  ) => void;\r\n  updateElementDuration: (\r\n    trackId: string,\r\n    elementId: string,\r\n    duration: number,\r\n    pushHistory?: boolean\r\n  ) => void;\r\n  updateElementStartTime: (\r\n    trackId: string,\r\n    elementId: string,\r\n    startTime: number,\r\n    pushHistory?: boolean\r\n  ) => void;\r\n  toggleTrackMute: (trackId: string) => void;\r\n  toggleElementHidden: (trackId: string, elementId: string) => void;\r\n\r\n  // Split operations for elements\r\n  splitElement: (\r\n    trackId: string,\r\n    elementId: string,\r\n    splitTime: number\r\n  ) => string | null;\r\n  splitAndKeepLeft: (\r\n    trackId: string,\r\n    elementId: string,\r\n    splitTime: number\r\n  ) => void;\r\n  splitAndKeepRight: (\r\n    trackId: string,\r\n    elementId: string,\r\n    splitTime: number\r\n  ) => void;\r\n  separateAudio: (trackId: string, elementId: string) => string | null;\r\n\r\n  // Replace media for an element\r\n  replaceElementMedia: (\r\n    trackId: string,\r\n    elementId: string,\r\n    newFile: File\r\n  ) => Promise<{ success: boolean; error?: string }>;\r\n\r\n  // Ripple editing functions\r\n  updateElementStartTimeWithRipple: (\r\n    trackId: string,\r\n    elementId: string,\r\n    newStartTime: number\r\n  ) => void;\r\n  removeElementFromTrackWithRipple: (\r\n    trackId: string,\r\n    elementId: string,\r\n    pushHistory?: boolean\r\n  ) => void;\r\n\r\n  // Computed values\r\n  getTotalDuration: () => number;\r\n  getProjectThumbnail: (projectId: string) => Promise<string | null>;\r\n\r\n  // History actions\r\n  undo: () => void;\r\n  redo: () => void;\r\n  pushHistory: () => void;\r\n\r\n  // Persistence actions\r\n  loadProjectTimeline: (projectId: string) => Promise<void>;\r\n  saveProjectTimeline: (projectId: string) => Promise<void>;\r\n  clearTimeline: () => void;\r\n  updateTextElement: (\r\n    trackId: string,\r\n    elementId: string,\r\n    updates: Partial<\r\n      Pick<\r\n        TextElement,\r\n        | \"content\"\r\n        | \"fontSize\"\r\n        | \"fontFamily\"\r\n        | \"color\"\r\n        | \"backgroundColor\"\r\n        | \"textAlign\"\r\n        | \"fontWeight\"\r\n        | \"fontStyle\"\r\n        | \"textDecoration\"\r\n        | \"x\"\r\n        | \"y\"\r\n        | \"rotation\"\r\n        | \"opacity\"\r\n      >\r\n    >\r\n  ) => void;\r\n  checkElementOverlap: (\r\n    trackId: string,\r\n    startTime: number,\r\n    duration: number,\r\n    excludeElementId?: string\r\n  ) => boolean;\r\n  findOrCreateTrack: (trackType: TrackType) => string;\r\n  addMediaAtTime: (item: MediaItem, currentTime?: number) => boolean;\r\n  addTextAtTime: (item: TextElement, currentTime?: number) => boolean;\r\n  addMediaToNewTrack: (item: MediaItem) => boolean;\r\n  addTextToNewTrack: (item: TextElement | DragData) => boolean;\r\n}\r\n\r\nexport const useTimelineStore = create<TimelineStore>((set, get) => {\r\n  // Helper to update tracks and maintain ordering\r\n  const updateTracks = (newTracks: TimelineTrack[]) => {\r\n    const tracksWithMain = ensureMainTrack(newTracks);\r\n    const sortedTracks = sortTracksByOrder(tracksWithMain);\r\n    set({\r\n      _tracks: tracksWithMain,\r\n      tracks: sortedTracks,\r\n    });\r\n  };\r\n\r\n  // Helper to auto-save timeline changes\r\n  const autoSaveTimeline = async () => {\r\n    const activeProject = useProjectStore.getState().activeProject;\r\n    if (activeProject) {\r\n      try {\r\n        await storageService.saveTimeline(activeProject.id, get()._tracks);\r\n      } catch (error) {\r\n        console.error(\"Failed to auto-save timeline:\", error);\r\n      }\r\n    }\r\n  };\r\n\r\n  // Helper to update tracks and auto-save\r\n  const updateTracksAndSave = (newTracks: TimelineTrack[]) => {\r\n    updateTracks(newTracks);\r\n    // Auto-save in background\r\n    setTimeout(autoSaveTimeline, 100);\r\n  };\r\n\r\n  // Initialize with proper track ordering\r\n  const initialTracks = ensureMainTrack([]);\r\n  const sortedInitialTracks = sortTracksByOrder(initialTracks);\r\n\r\n  return {\r\n    _tracks: initialTracks,\r\n    tracks: sortedInitialTracks,\r\n    history: [],\r\n    redoStack: [],\r\n    selectedElements: [],\r\n    rippleEditingEnabled: false,\r\n\r\n    // Snapping settings defaults\r\n    snappingEnabled: true,\r\n\r\n    getSortedTracks: () => {\r\n      const { _tracks } = get();\r\n      const tracksWithMain = ensureMainTrack(_tracks);\r\n      return sortTracksByOrder(tracksWithMain);\r\n    },\r\n\r\n    pushHistory: () => {\r\n      const { _tracks, history } = get();\r\n      set({\r\n        history: [...history, JSON.parse(JSON.stringify(_tracks))],\r\n        redoStack: [],\r\n      });\r\n    },\r\n\r\n    undo: () => {\r\n      const { history, redoStack, _tracks } = get();\r\n      if (history.length === 0) return;\r\n      const prev = history[history.length - 1];\r\n      updateTracksAndSave(prev);\r\n      set({\r\n        history: history.slice(0, -1),\r\n        redoStack: [...redoStack, JSON.parse(JSON.stringify(_tracks))],\r\n      });\r\n    },\r\n\r\n    selectElement: (trackId, elementId, multi = false) => {\r\n      set((state) => {\r\n        const exists = state.selectedElements.some(\r\n          (c) => c.trackId === trackId && c.elementId === elementId\r\n        );\r\n        if (multi) {\r\n          return exists\r\n            ? {\r\n                selectedElements: state.selectedElements.filter(\r\n                  (c) => !(c.trackId === trackId && c.elementId === elementId)\r\n                ),\r\n              }\r\n            : {\r\n                selectedElements: [\r\n                  ...state.selectedElements,\r\n                  { trackId, elementId },\r\n                ],\r\n              };\r\n        }\r\n        return { selectedElements: [{ trackId, elementId }] };\r\n      });\r\n    },\r\n\r\n    deselectElement: (trackId, elementId) => {\r\n      set((state) => ({\r\n        selectedElements: state.selectedElements.filter(\r\n          (c) => !(c.trackId === trackId && c.elementId === elementId)\r\n        ),\r\n      }));\r\n    },\r\n\r\n    clearSelectedElements: () => {\r\n      set({ selectedElements: [] });\r\n    },\r\n\r\n    setSelectedElements: (elements) => set({ selectedElements: elements }),\r\n\r\n    addTrack: (type) => {\r\n      get().pushHistory();\r\n\r\n      // Generate proper track name based on type\r\n      const trackName =\r\n        type === \"media\"\r\n          ? \"Media Track\"\r\n          : type === \"text\"\r\n            ? \"Text Track\"\r\n            : type === \"audio\"\r\n              ? \"Audio Track\"\r\n              : \"Track\";\r\n\r\n      const newTrack: TimelineTrack = {\r\n        id: generateUUID(),\r\n        name: trackName,\r\n        type,\r\n        elements: [],\r\n        muted: false,\r\n      };\r\n\r\n      updateTracksAndSave([...get()._tracks, newTrack]);\r\n      return newTrack.id;\r\n    },\r\n\r\n    insertTrackAt: (type, index) => {\r\n      get().pushHistory();\r\n\r\n      // Generate proper track name based on type\r\n      const trackName =\r\n        type === \"media\"\r\n          ? \"Media Track\"\r\n          : type === \"text\"\r\n            ? \"Text Track\"\r\n            : type === \"audio\"\r\n              ? \"Audio Track\"\r\n              : \"Track\";\r\n\r\n      const newTrack: TimelineTrack = {\r\n        id: generateUUID(),\r\n        name: trackName,\r\n        type,\r\n        elements: [],\r\n        muted: false,\r\n      };\r\n\r\n      const newTracks = [...get()._tracks];\r\n      newTracks.splice(index, 0, newTrack);\r\n      updateTracksAndSave(newTracks);\r\n      return newTrack.id;\r\n    },\r\n\r\n    removeTrack: (trackId) => {\r\n      const { rippleEditingEnabled } = get();\r\n\r\n      if (rippleEditingEnabled) {\r\n        get().removeTrackWithRipple(trackId);\r\n      } else {\r\n        get().pushHistory();\r\n        updateTracksAndSave(\r\n          get()._tracks.filter((track) => track.id !== trackId)\r\n        );\r\n      }\r\n    },\r\n\r\n    removeTrackWithRipple: (trackId) => {\r\n      const { _tracks } = get();\r\n      const trackToRemove = _tracks.find((t) => t.id === trackId);\r\n\r\n      if (!trackToRemove) return;\r\n\r\n      get().pushHistory();\r\n\r\n      // If track has no elements, just remove it normally\r\n      if (trackToRemove.elements.length === 0) {\r\n        updateTracksAndSave(_tracks.filter((track) => track.id !== trackId));\r\n        return;\r\n      }\r\n\r\n      // Find all the time ranges occupied by elements in the track being removed\r\n      const occupiedRanges = trackToRemove.elements.map((element) => ({\r\n        startTime: element.startTime,\r\n        endTime:\r\n          element.startTime +\r\n          (element.duration - element.trimStart - element.trimEnd),\r\n      }));\r\n\r\n      // Sort ranges by start time\r\n      occupiedRanges.sort((a, b) => a.startTime - b.startTime);\r\n\r\n      // Merge overlapping ranges to get consolidated gaps\r\n      const mergedRanges: Array<{\r\n        startTime: number;\r\n        endTime: number;\r\n        duration: number;\r\n      }> = [];\r\n\r\n      for (const range of occupiedRanges) {\r\n        if (mergedRanges.length === 0) {\r\n          mergedRanges.push({\r\n            startTime: range.startTime,\r\n            endTime: range.endTime,\r\n            duration: range.endTime - range.startTime,\r\n          });\r\n        } else {\r\n          const lastRange = mergedRanges[mergedRanges.length - 1];\r\n          if (range.startTime <= lastRange.endTime) {\r\n            // Overlapping or adjacent ranges, merge them\r\n            lastRange.endTime = Math.max(lastRange.endTime, range.endTime);\r\n            lastRange.duration = lastRange.endTime - lastRange.startTime;\r\n          } else {\r\n            // Non-overlapping range, add as new\r\n            mergedRanges.push({\r\n              startTime: range.startTime,\r\n              endTime: range.endTime,\r\n              duration: range.endTime - range.startTime,\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove the track and apply ripple effects to remaining tracks\r\n      const updatedTracks = _tracks\r\n        .filter((track) => track.id !== trackId)\r\n        .map((track) => {\r\n          const updatedElements = track.elements.map((element) => {\r\n            let newStartTime = element.startTime;\r\n\r\n            // Process gaps from right to left (latest to earliest) to avoid cumulative shifts\r\n            for (let i = mergedRanges.length - 1; i >= 0; i--) {\r\n              const gap = mergedRanges[i];\r\n              // If this element starts after the gap, shift it left by the gap duration\r\n              if (newStartTime >= gap.endTime) {\r\n                newStartTime -= gap.duration;\r\n              }\r\n            }\r\n\r\n            return {\r\n              ...element,\r\n              startTime: Math.max(0, newStartTime),\r\n            };\r\n          });\r\n\r\n          // Check for overlaps and resolve them if necessary\r\n          const hasOverlaps = checkElementOverlaps(updatedElements);\r\n          if (hasOverlaps) {\r\n            const resolvedElements = resolveElementOverlaps(updatedElements);\r\n            return { ...track, elements: resolvedElements };\r\n          }\r\n\r\n          return { ...track, elements: updatedElements };\r\n        });\r\n\r\n      updateTracksAndSave(updatedTracks);\r\n    },\r\n\r\n    addElementToTrack: (trackId, elementData) => {\r\n      get().pushHistory();\r\n\r\n      // Validate element type matches track type\r\n      const track = get()._tracks.find((t) => t.id === trackId);\r\n      if (!track) {\r\n        console.error(\"Track not found:\", trackId);\r\n        return;\r\n      }\r\n\r\n      // Use utility function for validation\r\n      const validation = validateElementTrackCompatibility(elementData, track);\r\n      if (!validation.isValid) {\r\n        console.error(validation.errorMessage);\r\n        return;\r\n      }\r\n\r\n      // For media elements, validate mediaId exists\r\n      if (elementData.type === \"media\" && !elementData.mediaId) {\r\n        console.error(\"Media element must have mediaId\");\r\n        return;\r\n      }\r\n\r\n      // For text elements, validate required text properties\r\n      if (elementData.type === \"text\" && !elementData.content) {\r\n        console.error(\"Text element must have content\");\r\n        return;\r\n      }\r\n\r\n      // Check if this is the first element being added to the timeline\r\n      const currentState = get();\r\n      const totalElementsInTimeline = currentState._tracks.reduce(\r\n        (total, track) => total + track.elements.length,\r\n        0\r\n      );\r\n      const isFirstElement = totalElementsInTimeline === 0;\r\n\r\n      const newElement: TimelineElement = {\r\n        ...elementData,\r\n        id: generateUUID(),\r\n        startTime: elementData.startTime || 0,\r\n        trimStart: 0,\r\n        trimEnd: 0,\r\n      } as TimelineElement; // Type assertion since we trust the caller passes valid data\r\n\r\n      // If this is the first element and it's a media element, automatically set the project canvas size\r\n      // to match the media's aspect ratio and FPS (for videos)\r\n      if (isFirstElement && newElement.type === \"media\") {\r\n        const mediaStore = useMediaStore.getState();\r\n        const mediaItem = mediaStore.mediaItems.find(\r\n          (item) => item.id === newElement.mediaId\r\n        );\r\n\r\n        if (\r\n          mediaItem &&\r\n          (mediaItem.type === \"image\" || mediaItem.type === \"video\")\r\n        ) {\r\n          const projectStore = useProjectStore.getState();\r\n          projectStore.updateCanvasSize(\r\n            findBestCanvasPreset(getMediaAspectRatio(mediaItem)),\r\n            \"original\"\r\n          );\r\n        }\r\n\r\n        // Set project FPS from the first video element\r\n        if (mediaItem && mediaItem.type === \"video\" && mediaItem.fps) {\r\n          const projectStore = useProjectStore.getState();\r\n          if (projectStore.activeProject) {\r\n            projectStore.updateProjectFps(mediaItem.fps);\r\n          }\r\n        }\r\n      }\r\n\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? { ...track, elements: [...track.elements, newElement] }\r\n            : track\r\n        )\r\n      );\r\n\r\n      get().selectElement(trackId, newElement.id);\r\n    },\r\n\r\n    removeElementFromTrack: (trackId, elementId, pushHistory = true) => {\r\n      const { rippleEditingEnabled } = get();\r\n\r\n      if (rippleEditingEnabled) {\r\n        get().removeElementFromTrackWithRipple(trackId, elementId, pushHistory);\r\n      } else {\r\n        if (pushHistory) get().pushHistory();\r\n        updateTracksAndSave(\r\n          get()\r\n            ._tracks.map((track) =>\r\n              track.id === trackId\r\n                ? {\r\n                    ...track,\r\n                    elements: track.elements.filter(\r\n                      (element) => element.id !== elementId\r\n                    ),\r\n                  }\r\n                : track\r\n            )\r\n            .filter((track) => track.elements.length > 0)\r\n        );\r\n      }\r\n    },\r\n\r\n    removeElementFromTrackWithRipple: (\r\n      trackId,\r\n      elementId,\r\n      pushHistory = true\r\n    ) => {\r\n      const { _tracks, rippleEditingEnabled } = get();\r\n\r\n      if (!rippleEditingEnabled) {\r\n        // If ripple editing is disabled, use regular removal\r\n        get().removeElementFromTrack(trackId, elementId, pushHistory);\r\n        return;\r\n      }\r\n\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((e) => e.id === elementId);\r\n\r\n      if (!element || !track) return;\r\n\r\n      if (pushHistory) get().pushHistory();\r\n\r\n      const elementStartTime = element.startTime;\r\n      const elementDuration =\r\n        element.duration - element.trimStart - element.trimEnd;\r\n      const elementEndTime = elementStartTime + elementDuration;\r\n\r\n      // Remove the element and shift all elements that come after it\r\n      const updatedTracks = _tracks\r\n        .map((currentTrack) => {\r\n          // Only apply ripple effects to the same track unless multi-track ripple is enabled\r\n          const shouldApplyRipple = currentTrack.id === trackId;\r\n\r\n          const updatedElements = currentTrack.elements\r\n            .filter((currentElement) => {\r\n              // Remove the target element\r\n              if (\r\n                currentElement.id === elementId &&\r\n                currentTrack.id === trackId\r\n              ) {\r\n                return false;\r\n              }\r\n              return true;\r\n            })\r\n            .map((currentElement) => {\r\n              // Only apply ripple effects if we should process this track\r\n              if (!shouldApplyRipple) {\r\n                return currentElement;\r\n              }\r\n\r\n              // Shift elements that start after the removed element\r\n              if (currentElement.startTime >= elementEndTime) {\r\n                return {\r\n                  ...currentElement,\r\n                  startTime: Math.max(\r\n                    0,\r\n                    currentElement.startTime - elementDuration\r\n                  ),\r\n                };\r\n              }\r\n              return currentElement;\r\n            });\r\n\r\n          // Check for overlaps and resolve them if necessary\r\n          const hasOverlaps = checkElementOverlaps(updatedElements);\r\n          if (hasOverlaps) {\r\n            // Resolve overlaps by adjusting element positions\r\n            const resolvedElements = resolveElementOverlaps(updatedElements);\r\n            return { ...currentTrack, elements: resolvedElements };\r\n          }\r\n\r\n          return { ...currentTrack, elements: updatedElements };\r\n        })\r\n        .filter((track) => track.elements.length > 0 || track.isMain);\r\n\r\n      updateTracksAndSave(updatedTracks);\r\n    },\r\n\r\n    moveElementToTrack: (fromTrackId, toTrackId, elementId) => {\r\n      get().pushHistory();\r\n\r\n      const fromTrack = get()._tracks.find((track) => track.id === fromTrackId);\r\n      const toTrack = get()._tracks.find((track) => track.id === toTrackId);\r\n      const elementToMove = fromTrack?.elements.find(\r\n        (element) => element.id === elementId\r\n      );\r\n\r\n      if (!elementToMove || !toTrack) return;\r\n\r\n      // Validate element type compatibility with target track\r\n      const validation = validateElementTrackCompatibility(\r\n        elementToMove,\r\n        toTrack\r\n      );\r\n      if (!validation.isValid) {\r\n        console.error(validation.errorMessage);\r\n        return;\r\n      }\r\n\r\n      const newTracks = get()\r\n        ._tracks.map((track) => {\r\n          if (track.id === fromTrackId) {\r\n            return {\r\n              ...track,\r\n              elements: track.elements.filter(\r\n                (element) => element.id !== elementId\r\n              ),\r\n            };\r\n          }\r\n          if (track.id === toTrackId) {\r\n            return {\r\n              ...track,\r\n              elements: [...track.elements, elementToMove],\r\n            };\r\n          }\r\n          return track;\r\n        })\r\n        .filter((track) => track.elements.length > 0);\r\n\r\n      updateTracksAndSave(newTracks);\r\n    },\r\n\r\n    updateElementTrim: (\r\n      trackId,\r\n      elementId,\r\n      trimStart,\r\n      trimEnd,\r\n      pushHistory = true\r\n    ) => {\r\n      if (pushHistory) get().pushHistory();\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((element) =>\r\n                  element.id === elementId\r\n                    ? { ...element, trimStart, trimEnd }\r\n                    : element\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    updateElementDuration: (\r\n      trackId,\r\n      elementId,\r\n      duration,\r\n      pushHistory = true\r\n    ) => {\r\n      if (pushHistory) get().pushHistory();\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((element) =>\r\n                  element.id === elementId ? { ...element, duration } : element\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    updateElementStartTime: (\r\n      trackId,\r\n      elementId,\r\n      startTime,\r\n      pushHistory = true\r\n    ) => {\r\n      if (pushHistory) get().pushHistory();\r\n      const clampedStartTime = Math.max(0, startTime);\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((element) =>\r\n                  element.id === elementId\r\n                    ? { ...element, startTime: clampedStartTime }\r\n                    : element\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    updateElementStartTimeWithRipple: (trackId, elementId, newStartTime) => {\r\n      const { _tracks, rippleEditingEnabled } = get();\r\n\r\n      if (!rippleEditingEnabled) {\r\n        // If ripple editing is disabled, use regular update\r\n        get().updateElementStartTime(trackId, elementId, newStartTime);\r\n        return;\r\n      }\r\n\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((e) => e.id === elementId);\r\n\r\n      if (!element || !track) return;\r\n\r\n      get().pushHistory();\r\n\r\n      const oldStartTime = element.startTime;\r\n      const oldEndTime =\r\n        element.startTime +\r\n        (element.duration - element.trimStart - element.trimEnd);\r\n      const newEndTime =\r\n        newStartTime + (element.duration - element.trimStart - element.trimEnd);\r\n      const timeDelta = newStartTime - oldStartTime;\r\n\r\n      // Update tracks based on multi-track ripple setting\r\n      const updatedTracks = _tracks.map((currentTrack) => {\r\n        // Only apply ripple effects to the same track unless multi-track ripple is enabled\r\n        const shouldApplyRipple = currentTrack.id === trackId;\r\n\r\n        const updatedElements = currentTrack.elements.map((currentElement) => {\r\n          if (currentElement.id === elementId && currentTrack.id === trackId) {\r\n            return { ...currentElement, startTime: Math.max(0, newStartTime) };\r\n          }\r\n\r\n          // Only apply ripple effects if we should process this track\r\n          if (!shouldApplyRipple) {\r\n            return currentElement;\r\n          }\r\n\r\n          // For ripple editing, we need to move elements that come after the moved element\r\n          const currentElementStart = currentElement.startTime;\r\n          const currentElementEnd =\r\n            currentElement.startTime +\r\n            (currentElement.duration -\r\n              currentElement.trimStart -\r\n              currentElement.trimEnd);\r\n\r\n          // If moving element to the right (positive delta)\r\n          if (timeDelta > 0) {\r\n            // Move elements that start after the original position of the moved element\r\n            if (currentElementStart >= oldEndTime) {\r\n              return {\r\n                ...currentElement,\r\n                startTime: currentElementStart + timeDelta,\r\n              };\r\n            }\r\n          }\r\n          // If moving element to the left (negative delta)\r\n          else if (timeDelta < 0) {\r\n            // Move elements that start after the new position of the moved element\r\n            if (\r\n              currentElementStart >= newEndTime &&\r\n              currentElementStart >= oldStartTime\r\n            ) {\r\n              return {\r\n                ...currentElement,\r\n                startTime: Math.max(0, currentElementStart + timeDelta),\r\n              };\r\n            }\r\n          }\r\n\r\n          return currentElement;\r\n        });\r\n\r\n        // Check for overlaps and resolve them if necessary\r\n        const hasOverlaps = checkElementOverlaps(updatedElements);\r\n        if (hasOverlaps) {\r\n          // Resolve overlaps by adjusting element positions\r\n          const resolvedElements = resolveElementOverlaps(updatedElements);\r\n          return { ...currentTrack, elements: resolvedElements };\r\n        }\r\n\r\n        return { ...currentTrack, elements: updatedElements };\r\n      });\r\n\r\n      updateTracksAndSave(updatedTracks);\r\n    },\r\n\r\n    toggleTrackMute: (trackId) => {\r\n      get().pushHistory();\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId ? { ...track, muted: !track.muted } : track\r\n        )\r\n      );\r\n    },\r\n\r\n    toggleElementHidden: (trackId, elementId) => {\r\n      get().pushHistory();\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((element) =>\r\n                  element.id === elementId\r\n                    ? { ...element, hidden: !element.hidden }\r\n                    : element\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    updateTextElement: (trackId, elementId, updates) => {\r\n      get().pushHistory();\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((element) =>\r\n                  element.id === elementId && element.type === \"text\"\r\n                    ? { ...element, ...updates }\r\n                    : element\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    splitElement: (trackId, elementId, splitTime) => {\r\n      const { _tracks } = get();\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((c) => c.id === elementId);\r\n\r\n      if (!element) return null;\r\n\r\n      const effectiveStart = element.startTime;\r\n      const effectiveEnd =\r\n        element.startTime +\r\n        (element.duration - element.trimStart - element.trimEnd);\r\n\r\n      if (splitTime <= effectiveStart || splitTime >= effectiveEnd) return null;\r\n\r\n      get().pushHistory();\r\n\r\n      const relativeTime = splitTime - element.startTime;\r\n      const firstDuration = relativeTime;\r\n      const secondDuration =\r\n        element.duration - element.trimStart - element.trimEnd - relativeTime;\r\n\r\n      const secondElementId = generateUUID();\r\n\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.flatMap((c) =>\r\n                  c.id === elementId\r\n                    ? [\r\n                        {\r\n                          ...c,\r\n                          trimEnd: c.trimEnd + secondDuration,\r\n                          name: getElementNameWithSuffix(c.name, \"left\"),\r\n                        },\r\n                        {\r\n                          ...c,\r\n                          id: secondElementId,\r\n                          startTime: splitTime,\r\n                          trimStart: c.trimStart + firstDuration,\r\n                          name: getElementNameWithSuffix(c.name, \"right\"),\r\n                        },\r\n                      ]\r\n                    : [c]\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n\r\n      return secondElementId;\r\n    },\r\n\r\n    // Split element and keep only the left portion\r\n    splitAndKeepLeft: (trackId, elementId, splitTime) => {\r\n      const { _tracks } = get();\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((c) => c.id === elementId);\r\n\r\n      if (!element) return;\r\n\r\n      const effectiveStart = element.startTime;\r\n      const effectiveEnd =\r\n        element.startTime +\r\n        (element.duration - element.trimStart - element.trimEnd);\r\n\r\n      if (splitTime <= effectiveStart || splitTime >= effectiveEnd) return;\r\n\r\n      get().pushHistory();\r\n\r\n      const relativeTime = splitTime - element.startTime;\r\n      const durationToRemove =\r\n        element.duration - element.trimStart - element.trimEnd - relativeTime;\r\n\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((c) =>\r\n                  c.id === elementId\r\n                    ? {\r\n                        ...c,\r\n                        trimEnd: c.trimEnd + durationToRemove,\r\n                        name: getElementNameWithSuffix(c.name, \"left\"),\r\n                      }\r\n                    : c\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    // Split element and keep only the right portion\r\n    splitAndKeepRight: (trackId, elementId, splitTime) => {\r\n      const { _tracks } = get();\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((c) => c.id === elementId);\r\n\r\n      if (!element) return;\r\n\r\n      const effectiveStart = element.startTime;\r\n      const effectiveEnd =\r\n        element.startTime +\r\n        (element.duration - element.trimStart - element.trimEnd);\r\n\r\n      if (splitTime <= effectiveStart || splitTime >= effectiveEnd) return;\r\n\r\n      get().pushHistory();\r\n\r\n      const relativeTime = splitTime - element.startTime;\r\n\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((c) =>\r\n                  c.id === elementId\r\n                    ? {\r\n                        ...c,\r\n                        startTime: splitTime,\r\n                        trimStart: c.trimStart + relativeTime,\r\n                        name: getElementNameWithSuffix(c.name, \"right\"),\r\n                      }\r\n                    : c\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    // Extract audio from video element to an audio track\r\n    separateAudio: (trackId, elementId) => {\r\n      const { _tracks } = get();\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((c) => c.id === elementId);\r\n\r\n      if (!element || track?.type !== \"media\") return null;\r\n\r\n      get().pushHistory();\r\n\r\n      // Find existing audio track or prepare to create one\r\n      const existingAudioTrack = _tracks.find((t) => t.type === \"audio\");\r\n      const audioElementId = generateUUID();\r\n\r\n      if (existingAudioTrack) {\r\n        // Add audio element to existing audio track\r\n        updateTracksAndSave(\r\n          get()._tracks.map((track) =>\r\n            track.id === existingAudioTrack.id\r\n              ? {\r\n                  ...track,\r\n                  elements: [\r\n                    ...track.elements,\r\n                    {\r\n                      ...element,\r\n                      id: audioElementId,\r\n                      name: getElementNameWithSuffix(element.name, \"audio\"),\r\n                    },\r\n                  ],\r\n                }\r\n              : track\r\n          )\r\n        );\r\n      } else {\r\n        // Create new audio track with the audio element in a single atomic update\r\n        const newAudioTrack: TimelineTrack = {\r\n          id: generateUUID(),\r\n          name: \"Audio Track\",\r\n          type: \"audio\",\r\n          elements: [\r\n            {\r\n              ...element,\r\n              id: audioElementId,\r\n              name: getElementNameWithSuffix(element.name, \"audio\"),\r\n            },\r\n          ],\r\n          muted: false,\r\n        };\r\n\r\n        updateTracksAndSave([...get()._tracks, newAudioTrack]);\r\n      }\r\n\r\n      return audioElementId;\r\n    },\r\n\r\n    // Replace media for an element\r\n    replaceElementMedia: async (\r\n      trackId: string,\r\n      elementId: string,\r\n      newFile: File\r\n    ): Promise<{ success: boolean; error?: string }> => {\r\n      const { _tracks } = get();\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((c) => c.id === elementId);\r\n\r\n      if (!element) {\r\n        return { success: false, error: \"Timeline element not found\" };\r\n      }\r\n\r\n      if (element.type !== \"media\") {\r\n        return {\r\n          success: false,\r\n          error: \"Replace is only available for media clips\",\r\n        };\r\n      }\r\n\r\n      try {\r\n        const mediaStore = useMediaStore.getState();\r\n        const projectStore = useProjectStore.getState();\r\n\r\n        if (!projectStore.activeProject) {\r\n          return { success: false, error: \"No active project found\" };\r\n        }\r\n\r\n        // Import required media processing functions\r\n        const {\r\n          getFileType,\r\n          getImageDimensions,\r\n          generateVideoThumbnail,\r\n          getMediaDuration,\r\n        } = await import(\"./media-store\");\r\n\r\n        const fileType = getFileType(newFile);\r\n        if (!fileType) {\r\n          return {\r\n            success: false,\r\n            error:\r\n              \"Unsupported file type. Please select a video, audio, or image file.\",\r\n          };\r\n        }\r\n\r\n        // Process the new media file\r\n        const mediaData: any = {\r\n          name: newFile.name,\r\n          type: fileType,\r\n          file: newFile,\r\n          url: URL.createObjectURL(newFile),\r\n        };\r\n\r\n        try {\r\n          // Get media-specific metadata\r\n          if (fileType === \"image\") {\r\n            const { width, height } = await getImageDimensions(newFile);\r\n            mediaData.width = width;\r\n            mediaData.height = height;\r\n          } else if (fileType === \"video\") {\r\n            const [duration, { thumbnailUrl, width, height }] =\r\n              await Promise.all([\r\n                getMediaDuration(newFile),\r\n                generateVideoThumbnail(newFile),\r\n              ]);\r\n            mediaData.duration = duration;\r\n            mediaData.thumbnailUrl = thumbnailUrl;\r\n            mediaData.width = width;\r\n            mediaData.height = height;\r\n          } else if (fileType === \"audio\") {\r\n            mediaData.duration = await getMediaDuration(newFile);\r\n          }\r\n        } catch (error) {\r\n          return {\r\n            success: false,\r\n            error: `Failed to process ${fileType} file: ${error instanceof Error ? error.message : \"Unknown error\"}`,\r\n          };\r\n        }\r\n\r\n        // Add new media item to store\r\n        try {\r\n          await mediaStore.addMediaItem(\r\n            projectStore.activeProject.id,\r\n            mediaData\r\n          );\r\n        } catch (error) {\r\n          return {\r\n            success: false,\r\n            error: `Failed to add media to project: ${error instanceof Error ? error.message : \"Unknown error\"}`,\r\n          };\r\n        }\r\n\r\n        // Find the newly created media item\r\n        const newMediaItem = mediaStore.mediaItems.find(\r\n          (item) => item.file === newFile\r\n        );\r\n\r\n        if (!newMediaItem) {\r\n          return {\r\n            success: false,\r\n            error: \"Failed to create media item in project. Please try again.\",\r\n          };\r\n        }\r\n\r\n        get().pushHistory();\r\n\r\n        // Update the timeline element to reference the new media\r\n        updateTracksAndSave(\r\n          _tracks.map((track) =>\r\n            track.id === trackId\r\n              ? {\r\n                  ...track,\r\n                  elements: track.elements.map((c) =>\r\n                    c.id === elementId\r\n                      ? {\r\n                          ...c,\r\n                          mediaId: newMediaItem.id,\r\n                          name: newMediaItem.name,\r\n                          // Update duration if the new media has a different duration\r\n                          duration: newMediaItem.duration || c.duration,\r\n                        }\r\n                      : c\r\n                  ),\r\n                }\r\n              : track\r\n          )\r\n        );\r\n\r\n        return { success: true };\r\n      } catch (error) {\r\n        console.error(\"Failed to replace element media:\", error);\r\n        return {\r\n          success: false,\r\n          error: `Unexpected error: ${error instanceof Error ? error.message : \"Unknown error\"}`,\r\n        };\r\n      }\r\n    },\r\n\r\n    getTotalDuration: () => {\r\n      const { _tracks } = get();\r\n      if (_tracks.length === 0) return 0;\r\n\r\n      const trackEndTimes = _tracks.map((track) =>\r\n        track.elements.reduce((maxEnd, element) => {\r\n          const elementEnd =\r\n            element.startTime +\r\n            element.duration -\r\n            element.trimStart -\r\n            element.trimEnd;\r\n          return Math.max(maxEnd, elementEnd);\r\n        }, 0)\r\n      );\r\n\r\n      return Math.max(...trackEndTimes, 0);\r\n    },\r\n\r\n    getProjectThumbnail: async (projectId) => {\r\n      try {\r\n        const tracks = await storageService.loadTimeline(projectId);\r\n        const mediaItems = await storageService.loadAllMediaItems(projectId);\r\n\r\n        if (!tracks || !mediaItems.length) return null;\r\n\r\n        const firstMediaElement = tracks\r\n          .flatMap((track) => track.elements)\r\n          .filter((element) => element.type === \"media\")\r\n          .sort((a, b) => a.startTime - b.startTime)[0];\r\n\r\n        if (!firstMediaElement) return null;\r\n\r\n        const mediaItem = mediaItems.find(\r\n          (item) => item.id === firstMediaElement.mediaId\r\n        );\r\n        if (!mediaItem) return null;\r\n\r\n        if (mediaItem.type === \"video\" && mediaItem.file) {\r\n          const { generateVideoThumbnail } = await import(\r\n            \"@/stores/media-store\"\r\n          );\r\n          const { thumbnailUrl } = await generateVideoThumbnail(mediaItem.file);\r\n          return thumbnailUrl;\r\n        }\r\n        if (mediaItem.type === \"image\" && mediaItem.url) {\r\n          return mediaItem.url;\r\n        }\r\n\r\n        return null;\r\n      } catch (error) {\r\n        console.error(\"Failed to get project thumbnail:\", error);\r\n        return null;\r\n      }\r\n    },\r\n\r\n    redo: () => {\r\n      const { redoStack } = get();\r\n      if (redoStack.length === 0) return;\r\n      const next = redoStack[redoStack.length - 1];\r\n      updateTracksAndSave(next);\r\n      set({ redoStack: redoStack.slice(0, -1) });\r\n    },\r\n\r\n    dragState: {\r\n      isDragging: false,\r\n      elementId: null,\r\n      trackId: null,\r\n      startMouseX: 0,\r\n      startElementTime: 0,\r\n      clickOffsetTime: 0,\r\n      currentTime: 0,\r\n    },\r\n\r\n    setDragState: (dragState) =>\r\n      set((state) => ({\r\n        dragState: { ...state.dragState, ...dragState },\r\n      })),\r\n\r\n    startDrag: (\r\n      elementId,\r\n      trackId,\r\n      startMouseX,\r\n      startElementTime,\r\n      clickOffsetTime\r\n    ) => {\r\n      set({\r\n        dragState: {\r\n          isDragging: true,\r\n          elementId,\r\n          trackId,\r\n          startMouseX,\r\n          startElementTime,\r\n          clickOffsetTime,\r\n          currentTime: startElementTime,\r\n        },\r\n      });\r\n    },\r\n\r\n    updateDragTime: (currentTime) => {\r\n      set((state) => ({\r\n        dragState: {\r\n          ...state.dragState,\r\n          currentTime,\r\n        },\r\n      }));\r\n    },\r\n\r\n    endDrag: () => {\r\n      set({\r\n        dragState: {\r\n          isDragging: false,\r\n          elementId: null,\r\n          trackId: null,\r\n          startMouseX: 0,\r\n          startElementTime: 0,\r\n          clickOffsetTime: 0,\r\n          currentTime: 0,\r\n        },\r\n      });\r\n    },\r\n\r\n    // Persistence methods\r\n    loadProjectTimeline: async (projectId) => {\r\n      try {\r\n        const tracks = await storageService.loadTimeline(projectId);\r\n        if (tracks) {\r\n          updateTracks(tracks);\r\n        } else {\r\n          // No timeline saved yet, initialize with default\r\n          const defaultTracks = ensureMainTrack([]);\r\n          updateTracks(defaultTracks);\r\n        }\r\n        // Clear history when loading a project\r\n        set({ history: [], redoStack: [] });\r\n      } catch (error) {\r\n        console.error(\"Failed to load timeline:\", error);\r\n        // Initialize with default on error\r\n        const defaultTracks = ensureMainTrack([]);\r\n        updateTracks(defaultTracks);\r\n        set({ history: [], redoStack: [] });\r\n      }\r\n    },\r\n\r\n    saveProjectTimeline: async (projectId) => {\r\n      try {\r\n        await storageService.saveTimeline(projectId, get()._tracks);\r\n      } catch (error) {\r\n        console.error(\"Failed to save timeline:\", error);\r\n      }\r\n    },\r\n\r\n    clearTimeline: () => {\r\n      const defaultTracks = ensureMainTrack([]);\r\n      updateTracks(defaultTracks);\r\n      set({ history: [], redoStack: [], selectedElements: [] });\r\n    },\r\n\r\n    // Snapping actions\r\n    toggleSnapping: () => {\r\n      set((state) => ({ snappingEnabled: !state.snappingEnabled }));\r\n    },\r\n\r\n    // Ripple editing functions\r\n    toggleRippleEditing: () => {\r\n      set((state) => ({\r\n        rippleEditingEnabled: !state.rippleEditingEnabled,\r\n      }));\r\n    },\r\n\r\n    checkElementOverlap: (trackId, startTime, duration, excludeElementId) => {\r\n      const track = get()._tracks.find((t) => t.id === trackId);\r\n      if (!track) return false;\r\n\r\n      const overlap = track.elements.some((element) => {\r\n        const elementEnd =\r\n          element.startTime +\r\n          element.duration -\r\n          element.trimStart -\r\n          element.trimEnd;\r\n\r\n        if (element.id === excludeElementId) {\r\n          return false;\r\n        }\r\n\r\n        return (\r\n          (startTime >= element.startTime && startTime < elementEnd) ||\r\n          (startTime + duration > element.startTime &&\r\n            startTime + duration <= elementEnd) ||\r\n          (startTime < element.startTime && startTime + duration > elementEnd)\r\n        );\r\n      });\r\n      return overlap;\r\n    },\r\n\r\n    findOrCreateTrack: (trackType) => {\r\n      // Always create new text track to allow multiple text elements\r\n      // Insert text tracks at the top\r\n      if (trackType === \"text\") {\r\n        return get().insertTrackAt(trackType, 0);\r\n      }\r\n\r\n      const existingTrack = get()._tracks.find((t) => t.type === trackType);\r\n      if (existingTrack) {\r\n        return existingTrack.id;\r\n      }\r\n\r\n      return get().addTrack(trackType);\r\n    },\r\n\r\n    addMediaAtTime: (item, currentTime = 0) => {\r\n      const trackType = item.type === \"audio\" ? \"audio\" : \"media\";\r\n      const duration =\r\n        item.duration || TIMELINE_CONSTANTS.DEFAULT_IMAGE_DURATION;\r\n\r\n      // Get all tracks of the right type\r\n      const tracks = get()._tracks.filter((t) => t.type === trackType);\r\n\r\n      // Try to find a track with no overlap\r\n      let targetTrackId = null;\r\n      for (const track of tracks) {\r\n        if (!get().checkElementOverlap(track.id, currentTime, duration)) {\r\n          targetTrackId = track.id;\r\n          break;\r\n        }\r\n      }\r\n\r\n      // If no free track found, create a new one\r\n      if (!targetTrackId) {\r\n        targetTrackId = get().addTrack(trackType);\r\n      }\r\n\r\n      get().addElementToTrack(targetTrackId, {\r\n        type: \"media\",\r\n        mediaId: item.id,\r\n        name: item.name,\r\n        duration,\r\n        startTime: currentTime,\r\n        trimStart: 0,\r\n        trimEnd: 0,\r\n      });\r\n      return true;\r\n    },\r\n\r\n    addTextAtTime: (item, currentTime = 0) => {\r\n      const targetTrackId = get().insertTrackAt(\"text\", 0); // Always create new text track at the top\r\n\r\n      get().addElementToTrack(targetTrackId, {\r\n        type: \"text\",\r\n        name: item.name || \"Text\",\r\n        content: item.content || \"Default Text\",\r\n        duration: item.duration || TIMELINE_CONSTANTS.DEFAULT_TEXT_DURATION,\r\n        startTime: currentTime,\r\n        trimStart: 0,\r\n        trimEnd: 0,\r\n        fontSize: item.fontSize || 48,\r\n        fontFamily: item.fontFamily || \"Arial\",\r\n        color: item.color || \"#ffffff\",\r\n        backgroundColor: item.backgroundColor || \"transparent\",\r\n        textAlign: item.textAlign || \"center\",\r\n        fontWeight: item.fontWeight || \"normal\",\r\n        fontStyle: item.fontStyle || \"normal\",\r\n        textDecoration: item.textDecoration || \"none\",\r\n        x: item.x || 0,\r\n        y: item.y || 0,\r\n        rotation: item.rotation || 0,\r\n        opacity: item.opacity !== undefined ? item.opacity : 1,\r\n      });\r\n      return true;\r\n    },\r\n\r\n    addMediaToNewTrack: (item) => {\r\n      const trackType = item.type === \"audio\" ? \"audio\" : \"media\";\r\n      const targetTrackId = get().findOrCreateTrack(trackType);\r\n\r\n      get().addElementToTrack(targetTrackId, {\r\n        type: \"media\",\r\n        mediaId: item.id,\r\n        name: item.name,\r\n        duration: item.duration || TIMELINE_CONSTANTS.DEFAULT_IMAGE_DURATION,\r\n        startTime: 0,\r\n        trimStart: 0,\r\n        trimEnd: 0,\r\n      });\r\n      return true;\r\n    },\r\n\r\n    addTextToNewTrack: (item) => {\r\n      const targetTrackId = get().insertTrackAt(\"text\", 0); // Always create new text track at the top\r\n\r\n      get().addElementToTrack(targetTrackId, {\r\n        type: \"text\",\r\n        name: item.name || \"Text\",\r\n        content:\r\n          (\"content\" in item ? item.content : \"Default Text\") || \"Default Text\",\r\n        duration: TIMELINE_CONSTANTS.DEFAULT_TEXT_DURATION,\r\n        startTime: 0,\r\n        trimStart: 0,\r\n        trimEnd: 0,\r\n        fontSize: (\"fontSize\" in item ? item.fontSize : 48) || 48,\r\n        fontFamily:\r\n          (\"fontFamily\" in item ? item.fontFamily : \"Arial\") || \"Arial\",\r\n        color: (\"color\" in item ? item.color : \"#ffffff\") || \"#ffffff\",\r\n        backgroundColor:\r\n          (\"backgroundColor\" in item ? item.backgroundColor : \"transparent\") ||\r\n          \"transparent\",\r\n        textAlign:\r\n          (\"textAlign\" in item ? item.textAlign : \"center\") || \"center\",\r\n        fontWeight:\r\n          (\"fontWeight\" in item ? item.fontWeight : \"normal\") || \"normal\",\r\n        fontStyle:\r\n          (\"fontStyle\" in item ? item.fontStyle : \"normal\") || \"normal\",\r\n        textDecoration:\r\n          (\"textDecoration\" in item ? item.textDecoration : \"none\") || \"none\",\r\n        x: (\"x\" in item ? item.x : 0) || 0,\r\n        y: (\"y\" in item ? item.y : 0) || 0,\r\n        rotation: (\"rotation\" in item ? item.rotation : 0) || 0,\r\n        opacity:\r\n          \"opacity\" in item && item.opacity !== undefined ? item.opacity : 1,\r\n      });\r\n      return true;\r\n    },\r\n  };\r\n});\r\n","// Generic utilities\r\n\r\nimport { type ClassValue, clsx } from \"clsx\";\r\nimport { twMerge } from \"tailwind-merge\";\r\n\r\nexport function cn(...inputs: ClassValue[]) {\r\n  return twMerge(clsx(inputs));\r\n}\r\n\r\n/**\r\n * Generates a UUID v4 string\r\n * Uses crypto.randomUUID() if available, otherwise falls back to a custom implementation\r\n */\r\nexport function generateUUID(): string {\r\n  // Use the native crypto.randomUUID if available\r\n  if (\r\n    typeof crypto !== \"undefined\" &&\r\n    typeof crypto.randomUUID === \"function\"\r\n  ) {\r\n    return crypto.randomUUID();\r\n  }\r\n\r\n  // Secure fallback using crypto.getRandomValues\r\n  const bytes = new Uint8Array(16);\r\n  crypto.getRandomValues(bytes);\r\n\r\n  // Set version 4 (UUIDv4)\r\n  bytes[6] = (bytes[6] & 0x0f) | 0x40;\r\n  // Set variant 10xxxxxx\r\n  bytes[8] = (bytes[8] & 0x3f) | 0x80;\r\n\r\n  const hex = [...bytes].map((b) => b.toString(16).padStart(2, \"0\"));\r\n\r\n  return (\r\n    hex.slice(0, 4).join(\"\") +\r\n    \"-\" +\r\n    hex.slice(4, 6).join(\"\") +\r\n    \"-\" +\r\n    hex.slice(6, 8).join(\"\") +\r\n    \"-\" +\r\n    hex.slice(8, 10).join(\"\") +\r\n    \"-\" +\r\n    hex.slice(10, 16).join(\"\")\r\n  );\r\n}\r\n\r\nexport function isDOMElement(el: any): el is HTMLElement {\r\n  return !!el && (el instanceof Element || el instanceof HTMLElement);\r\n}\r\n\r\nexport function isTypableElement(el: HTMLElement): boolean {\r\n  // If content editable, then it is editable\r\n  if (el.isContentEditable) return true;\r\n\r\n  // If element is an input and the input is enabled, then it is typable\r\n  if (el.tagName === \"INPUT\") {\r\n    return !(el as HTMLInputElement).disabled;\r\n  }\r\n  // If element is a textarea and the input is enabled, then it is typable\r\n  if (el.tagName === \"TEXTAREA\") {\r\n    return !(el as HTMLTextAreaElement).disabled;\r\n  }\r\n\r\n  return false;\r\n}\r\nexport function isAppleDevice() {\r\n  return /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\r\n}\r\n\r\nexport function getPlatformSpecialKey() {\r\n  return isAppleDevice() ? \"⌘\" : \"Ctrl\";\r\n}\r\n\r\nexport function getPlatformAlternateKey() {\r\n  return isAppleDevice() ? \"⌥\" : \"Alt\";\r\n}\r\n"],"names":["sortTracksByOrder","tracks","sort","a","b","type","isMain","getMainTrack","find","track","ensureMainTrack","some","hasMainTrack","id","generateUUID","name","elements","muted","canElementGoOnTrack","elementType","trackType","validateElementTrackCompatibility","element","isValid","errorMessage","IndexedDBAdapter","getDB","Promise","resolve","reject","request","indexedDB","open","dbName","version","onerror","error","onsuccess","result","onupgradeneeded","event","db","target","objectStoreNames","contains","storeName","createObjectStore","keyPath","get","key","store","transaction","objectStore","set","value","put","remove","delete","list","getAllKeys","clear","OPFSAdapter","getDirectory","opfsRoot","navigator","storage","getDirectoryHandle","directoryName","create","directory","fileHandle","getFileHandle","getFile","file","writable","createWritable","write","close","removeEntry","keys","push","isSupported","StorageService","getProjectMediaAdapters","projectId","mediaMetadataAdapter","config","mediaDb","mediaFilesAdapter","getProjectTimelineAdapter","timelineDb","saveProject","project","serializedProject","thumbnail","createdAt","toISOString","updatedAt","backgroundColor","backgroundType","blurIntensity","bookmarks","fps","canvasSize","canvasMode","projectsAdapter","loadProject","Date","loadAllProjects","projectIds","projects","getTime","deleteProject","saveMediaItem","mediaItem","metadata","size","lastModified","width","height","duration","loadMediaItem","all","url","URL","createObjectURL","loadAllMediaItems","mediaIds","mediaItems","item","deleteMediaItem","deleteProjectMedia","saveTimeline","timelineAdapter","timelineData","loadTimeline","deleteProjectTimeline","clearAllData","getStorageInfo","length","isOPFSSupported","isIndexedDBSupported","getProjectStorageInfo","hasTimeline","loadSavedSounds","savedSoundsAdapter","sounds","saveSoundEffect","soundEffect","currentData","sound","savedSound","username","previewUrl","downloadUrl","tags","license","savedAt","updatedData","removeSavedSound","soundId","filter","isSoundSaved","clearSavedSounds","window","isFullySupported","projectsDb","savedSoundsDb","storageService","getFileType","startsWith","img","Image","addEventListener","naturalWidth","naturalHeight","src","generateVideoThumbnail","video","document","createElement","canvas","ctx","getContext","videoWidth","videoHeight","currentTime","Math","min","drawImage","thumbnailUrl","toDataURL","load","getMediaDuration","getMediaAspectRatio","useMediaStore","isLoading","addMediaItem","newItem","state","media","removeMediaItem","revokeObjectURL","removeElementFromTrack","removeElementFromTrackWithRipple","rippleEditingEnabled","pushHistory","useTimelineStore","timeline","getState","elementsToRemove","el","mediaId","trackId","elementId","loadProjectMedia","updatedMediaItems","map","clearProjectMedia","forEach","clearAllMedia","DEFAULT_CANVAS_SIZE","useProjectStore","savedProjects","isInitialized","invalidProjectIds","Set","toggleBookmark","time","updatedBookmarks","activeProject","frameTime","round","bookmarkIndex","findIndex","abs","bookmark","_","i","updatedProject","toast","description","isBookmarked","removeBookmark","createNewProject","newProject","DEFAULT_PROJECT","mediaStore","timelineStore","clearTimeline","loadProjectTimeline","saveCurrentProject","saveProjectTimeline","closeProject","renameProject","projectToRename","p","Error","message","duplicateProject","numberMatch","match","baseName","existingNumbers","nextNumber","max","updateProjectBackground","updateBackgroundType","options","updateProjectFps","updateCanvasSize","mode","getFilteredAndSortedProjects","searchQuery","sortOption","sortedProjects","toLowerCase","includes","order","split","aValue","bValue","undefined","isInvalidProjectId","invalidIds","has","markProjectIdAsInvalid","clearInvalidProjectIds","TRACK_COLORS","solid","background","border","text","audio","getTrackElementClasses","colors","getTrackColors","TRACK_HEIGHTS","getTrackHeight","getCumulativeHeightBefore","trackIndex","slice","reduce","sum","GAP","getTotalTracksHeight","gapsHeight","TIMELINE_CONSTANTS","ELEMENT_MIN_WIDTH","PIXELS_PER_SECOND","TRACK_HEIGHT","DEFAULT_TEXT_DURATION","DEFAULT_IMAGE_DURATION","ZOOM_LEVELS","label","snapTimeToFrame","frame","DEFAULT_CANVAS_PRESETS","checkElementOverlaps","sortedElements","startTime","current","next","trimStart","trimEnd","resolvedElements","previous","previousEnd","originalName","suffix","replace","updateTracks","tracksWithMain","newTracks","sortedTracks","_tracks","autoSaveTimeline","updateTracksAndSave","setTimeout","initialTracks","sortedInitialTracks","history","redoStack","selectedElements","snappingEnabled","getSortedTracks","JSON","parse","stringify","undo","selectElement","multi","exists","c","deselectElement","clearSelectedElements","setSelectedElements","addTrack","newTrack","trackName","insertTrackAt","index","splice","removeTrack","removeTrackWithRipple","trackToRemove","t","occupiedRanges","endTime","mergedRanges","range","lastRange","updatedTracks","updatedElements","newStartTime","gap","hasOverlaps","resolveElementOverlaps","addElementToTrack","elementData","content","totalElementsInTimeline","total","newElement","projectStore","findBestCanvasPreset","bestMatch","smallestDifference","aspectRatio","preset","difference","presetAspectRatio","bestAspectRatio","e","elementStartTime","elementDuration","elementEndTime","shouldApplyRipple","currentTrack","currentElement","moveElementToTrack","fromTrackId","toTrackId","fromTrack","toTrack","elementToMove","validation","updateElementTrim","updateElementDuration","updateElementStartTime","clampedStartTime","updateElementStartTimeWithRipple","oldStartTime","oldEndTime","newEndTime","timeDelta","currentElementStart","toggleTrackMute","toggleElementHidden","hidden","updateTextElement","updates","splitElement","splitTime","effectiveStart","effectiveEnd","relativeTime","secondDuration","secondElementId","flatMap","getElementNameWithSuffix","firstDuration","splitAndKeepLeft","durationToRemove","splitAndKeepRight","separateAudio","existingAudioTrack","audioElementId","newAudioTrack","replaceElementMedia","newFile","success","getImageDimensions","fileType","mediaData","newMediaItem","getTotalDuration","maxEnd","elementEnd","getProjectThumbnail","firstMediaElement","redo","dragState","isDragging","startMouseX","startElementTime","clickOffsetTime","setDragState","startDrag","updateDragTime","endDrag","defaultTracks","toggleSnapping","toggleRippleEditing","checkElementOverlap","excludeElementId","findOrCreateTrack","existingTrack","addMediaAtTime","targetTrackId","addTextAtTime","fontSize","fontFamily","color","textAlign","fontWeight","fontStyle","textDecoration","x","y","rotation","opacity","addMediaToNewTrack","addTextToNewTrack","cn","inputs","twMerge","clsx","crypto","randomUUID","bytes","Uint8Array","getRandomValues","hex","toString","padStart","join","isDOMElement","Element","HTMLElement","isTypableElement","isContentEditable","tagName","disabled","isAppleDevice","test","platform","getPlatformSpecialKey","getPlatformAlternateKey"],"sourceRoot":"","ignoreList":[]}